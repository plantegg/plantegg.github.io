<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Arthas - 标签 - plantegg</title>
        <link>http://localhost:1313/tags/arthas/</link>
        <description>Arthas - 标签 - plantegg</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Fri, 27 Sep 2019 13:30:03 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/tags/arthas/" rel="self" type="application/rss+xml" /><item>
    <title>arthas常用命令速记</title>
    <link>http://localhost:1313/posts/arthas%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E8%AE%B0/</link>
    <pubDate>Fri, 27 Sep 2019 13:30:03 &#43;0000</pubDate><author>
        <name>作者</name>
    </author><guid>http://localhost:1313/posts/arthas%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E8%AE%B0/</guid>
    <description><![CDATA[<h1 id="arthas常用命令速记" class="headerLink">
    <a href="#arthas%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4%e9%80%9f%e8%ae%b0" class="header-mark"></a>arthas常用命令速记</h1><p><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/arthas</a></p>
<h2 id="thread" class="headerLink">
    <a href="#thread" class="header-mark"></a>thread</h2><p>thread -n 3
thread 16</p>
<h2 id="jad-反编译" class="headerLink">
    <a href="#jad-%e5%8f%8d%e7%bc%96%e8%af%91" class="header-mark"></a>jad 反编译</h2><pre><code>jad org.slf4j.Logger
jad org.slf4j.Logger -c 61bbe9ba

jad com.taobao.tddl.common.IdGenerator
jad --source-only com.taobao.tddl.common.IdGenerator
jad --source-only com.taobao.tddl.common.IdGenerator &gt; /tmp/IdGenerator.java
</code></pre>
<p>反编译生成java代码</p>
<h2 id="mc-编译生成新的class" class="headerLink">
    <a href="#mc-%e7%bc%96%e8%af%91%e7%94%9f%e6%88%90%e6%96%b0%e7%9a%84class" class="header-mark"></a>mc 编译生成新的class</h2><p>将修改后的java代码编译成class（因为依赖的关系可能失败）</p>
<pre><code>mc /tmp/IdGenerator.java -d /tmp
</code></pre>
<h2 id="redefine-加载新的class" class="headerLink">
    <a href="#redefine-%e5%8a%a0%e8%bd%bd%e6%96%b0%e7%9a%84class" class="header-mark"></a>redefine 加载新的class</h2><p>将修改后的class代码热加载</p>
<pre><code>redefine /tmp/IdGenerator.class
redefine -c 1e80bfe8 /tmp/com/alibaba/middleware/drds/worker/task/RegisterTask.class
</code></pre>
<p>可以再次jad 反编译确认class中是修改后的代码：</p>
<pre><code>jad --source-only com.alibaba.cobar.server.ServerConnection &gt; /tmp/SC.java
</code></pre>
<p>有时候 redefine 看到成功，可是实际并不一定，最好再次 jad 确认一下。</p>
<p>线上环境快速修改代码验证三部曲：jad反编译得到源代码、修改后mc编译成class、redefine替换新的class。</p>
<h2 id="classload" class="headerLink">
    <a href="#classload" class="header-mark"></a>classload</h2><pre><code>classloader -l
classloader -c 1e80bfe8 -r com/alibaba/middleware/drds/worker/task/RegisterTask.class
classload -t
classload -c 6e0be858
classloader ch.qos.logback.core.AppenderBase
</code></pre>
<h2 id="sc" class="headerLink">
    <a href="#sc" class="header-mark"></a>sc</h2><pre><code>sc -d com.taobao.tddl.common.IdGenerator
sc -df ch.qos.logback.core.AppenderBase
</code></pre>
<h2 id="sm" class="headerLink">
    <a href="#sm" class="header-mark"></a>sm</h2><p>列出class的方法</p>
<pre><code>sm ch.qos.logback.core.AppenderBase -d
</code></pre>
<h2 id="getstatic-查看静态成员" class="headerLink">
    <a href="#getstatic-%e6%9f%a5%e7%9c%8b%e9%9d%99%e6%80%81%e6%88%90%e5%91%98" class="header-mark"></a>getstatic 查看静态成员</h2><p>通过getstatic查看静态成员，来追踪一个logger没有设置level的话他的输出级别到底是什么？</p>
<p>先 sc 获取classloader的hash</p>
<pre><code>sc -df io.netty.channel.nio.NioEventLoop

getstatic -c 1e80bfe8 io.netty.channel.nio.NioEventLoop logger 'getClass().getName()'
field: logger
@String[io.netty.util.internal.logging.Slf4JLogger]
Affect(row-cnt:1) cost in 5 ms.
</code></pre>
<p>然后查看 logger的具体内容，可以看到level等，level为null的话会从父logger继承：</p>
<pre><code>getstatic -c 1e80bfe8 io.netty.channel.nio.NioEventLoop logger 'logger'
field: logger
@Logger[
    serialVersionUID=@Long[5454405123156820674],
    FQCN=@String[ch.qos.logback.classic.Logger],
    name=@String[io.netty.channel.nio.NioEventLoop],
    level=null,
    effectiveLevelInt=@Integer[20000],
    parent=@Logger[Logger[io.netty.channel.nio]],
    childrenList=null,
    aai=null,
    additive=@Boolean[true],
    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],
]
</code></pre>
<p>再次用getstatic命令来确定jar包的location：</p>
<pre><code>getstatic -c 1e80bfe8 io.netty.channel.nio.NioEventLoop logger 'logger.getClass().getProtectionDomain().getCodeSource().getLocation()'
field: logger
@URL[
    BUILTIN_HANDLERS_PREFIX=@String[sun.net.www.protocol],
    serialVersionUID=@Long[-7627629688361524110],
    protocolPathProp=@String[java.protocol.handler.pkgs],
    protocol=@String[file],
    host=@String[],
    port=@Integer[-1],
    file=@String[/home/admin/drds-worker/lib/logback-classic-1.1.8.jar],
    query=null,
    authority=@String[],
    path=@String[/home/admin/drds-worker/lib/logback-classic-1.1.8.jar],
    userInfo=null,
    ref=null,
    hostAddress=null,
    handler=@Handler[sun.net.www.protocol.file.Handler@5a98007],
    hashCode=@Integer[-1217964899],
    tempState=null,
    factory=null,
    handlers=@Hashtable[isEmpty=false;size=3],
    streamHandlerLock=@Object[java.lang.Object@3bf379e9],
    serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=7],
]
</code></pre>
<p>然后通过getstatic来获取到这个parent属性的内容。然后通过多个parent操作，可以发现level都是INFO，最终发现ROOT level是INFO：</p>
<pre><code>getstatic -c 1e80bfe8 io.netty.channel.nio.NioEventLoop logger 'logger.parent.parent.parent.parent.parent'
field: logger
@Logger[
    serialVersionUID=@Long[5454405123156820674],
    FQCN=@String[ch.qos.logback.classic.Logger],
    name=@String[ROOT],
    level=@Level[INFO],
    effectiveLevelInt=@Integer[20000],
    parent=null,
    childrenList=@CopyOnWriteArrayList[isEmpty=false;size=4],
    aai=@AppenderAttachableImpl[ch.qos.logback.core.spi.AppenderAttachableImpl@3f0908e1],
    additive=@Boolean[true],
    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],
]
</code></pre>
<h2 id="logger-查看logger配置" class="headerLink">
    <a href="#logger-%e6%9f%a5%e7%9c%8blogger%e9%85%8d%e7%bd%ae" class="header-mark"></a>logger 查看logger配置</h2><p>列出所有logger，然后修改logger的level</p>
<pre><code>classloader -l
logger -c 27bc2616
ognl -c 6e0be858 '@com.alibaba.cobar.server.ServerConnection@logger'
ognl -c 6e0be858 '@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)'
</code></pre>
<p>或者</p>
<pre><code>logger --name ROOT --level debug
</code></pre>
<h2 id="trace-耗时超过10ms的方法堆栈" class="headerLink">
    <a href="#trace-%e8%80%97%e6%97%b6%e8%b6%85%e8%bf%8710ms%e7%9a%84%e6%96%b9%e6%b3%95%e5%a0%86%e6%a0%88" class="header-mark"></a>trace 耗时超过10ms的方法堆栈</h2><p>查看调用耗时超过 10ms的函数堆栈</p>
<pre><code>stack ch.qos.logback.core.AppenderBase doAppend
trace -j ch.qos.logback.core.AppenderBase doAppend '#cost &gt; 10'
</code></pre>
<p><img class="tw-inline" loading="lazy" src=http://localhost:1313/Users/ren/case/ossimg/a62e3703ec9f3fef024fef4ff39441c7.png   alt="image.png"  ></p>
<p>截图中红框的数字表示代码行号</p>
<h2 id="ongl-调用static函数并查看返回值" class="headerLink">
    <a href="#ongl-%e8%b0%83%e7%94%a8static%e5%87%bd%e6%95%b0%e5%b9%b6%e6%9f%a5%e7%9c%8b%e8%bf%94%e5%9b%9e%e5%80%bc" class="header-mark"></a>ongl 调用static函数并查看返回值</h2><pre><code>ognl '#value1=@com.alibaba.middleware.drds.manager.common.utils.AddressUtil@getHostIp(), {#value1}'
@ArrayList[
	@String[10.0.174.135],
]


 ognl '#value1=@com.alibaba.middleware.drds.worker.Config@getInstance(), {#value1}'
	@ArrayList[
@Config[Config(receivedManagerInfo=true, registeredToManager=true, workerRpcPort=8188, managerIp=10.0.171.193, managerPort=8080, drdsServerPort=3306, drdsManagerPort=3406, host=10.0.118.18, vpcId=vpc-bp1tsocjn451k7ur52vwl, urlToGetVpcId=http://100.100.100.200/latest/meta-data/vpc-id, heartBeatIntervalSeconds=180, registerInveralSeconds=2, manageDrdsIntervalSeconds=60, miniVersion=1, version=0.0.0.41, registerUrl=http://hostPlaceHolder:portPlaceHolder/v1/worker/register, heartBeatUrl=http://hostPlaceHolder:portPlaceHolder/v1/worker/heartBeat, manageDrdsServerUrl=http://hostPlaceHolder:portPlaceHolder/v1/worker/manageDrdsServer, gotVpcId=true, nodeType=drds-server, watcher=null, scheduledThreadPoolExecutor=java.util.concurrent.ScheduledThreadPoolExecutor@3aa3f85f[Running, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0])],
]

#Netty的SelectorProvider.provider()创建Selector驱动的时候通过JDK create到的Selector驱动
#如果是windows平台：WindowsSelectorProvider(); macOS
#下面是Linux平台的默认Selector驱动：
$ options unsafe true
$ ognl  '#value1=@sun.nio.ch.DefaultSelectorProvider@create(), {#value1}'
@ArrayList[
    @EPollSelectorProvider[sun.nio.ch.EPollSelectorProvider@5bf6cb51],
]
#或者
$  ognl  '#value1=@java.nio.channels.spi.SelectorProvider@provider(), {#value1}'
@ArrayList[
    @EPollSelectorProvider[sun.nio.ch.EPollSelectorProvider@74c4ede7],
]
</code></pre>
<h2 id="tt-观察函数调用和回放" class="headerLink">
    <a href="#tt-%e8%a7%82%e5%af%9f%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%92%8c%e5%9b%9e%e6%94%be" class="header-mark"></a>tt 观察函数调用和回放</h2><p>先通过tt观察某个函数的调用，然后再用 tt -i 回放这个调用并查看返回值等</p>
<pre><code>tt -t com.alibaba.middleware.drds.manager.common.utils.AddressUtil getHostIp
tt -t com.alibaba.middleware.drds.worker.task.RegisterTask getHostInfoIfNeeded
tt -i 1000
tt -i 1000 -p
tt -n 3 -t com.alibaba.middleware.drds.worker.task.RegisterTask getHostInfoIfNeeded
tt -n 3 -t com.alibaba.middleware.drds.manager.common.utils.AddressUtil getHostIp

 tt -i 1010 -p
	 RE-INDEX      1010
	 GMT-REPLAY    2019-09-27 12:59:05
	 OBJECT        NULL
	 CLASS         com.alibaba.middleware.drds.manager.common.utils.AddressUtil
	 METHOD        getHostIp
	 IS-RETURN     true
	 IS-EXCEPTION  false
	 COST(ms)      0.577817
	 RETURN-OBJ    @String[10.0.118.18]
</code></pre>
<h2 id="watch-查看函数调用的参数内容和返回值" class="headerLink">
    <a href="#watch-%e6%9f%a5%e7%9c%8b%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e7%9a%84%e5%8f%82%e6%95%b0%e5%86%85%e5%ae%b9%e5%92%8c%e8%bf%94%e5%9b%9e%e5%80%bc" class="header-mark"></a>watch 查看函数调用的参数内容和返回值</h2><p>指定输出结果的属性遍历深度，默认为 1：</p>
<pre><code>watch  com.alibaba.middleware.drds.manager.common.utils.AddressUtil getHostIp &quot;{params,returnObj}&quot; -x 2

watch com.alibaba.middleware.drds.worker.task.RegisterTask getHostInfoIfNeeded &quot;{params,returnObj}&quot; -x 2
	Press Q or Ctrl+C to abort.
	Affect(class-cnt:1 , method-cnt:1) cost in 56 ms.
	ts=2019-09-27 13:24:00; [cost=0.2698ms] result=@ArrayList[
	    @Object[][isEmpty=true;size=0],
	    @Boolean[true],
	]
	ts=2019-09-27 13:24:02; [cost=0.030039ms] result=@ArrayList[
	    @Object[][isEmpty=true;size=0],
	    @Boolean[true],
	]
</code></pre>
<p>可以看到处理请求的handler是 om.example.demo.arthas.user.UserController.findUserById：</p>
<pre><code>$ watch org.springframework.web.servlet.DispatcherServlet getHandler returnObj
Press Q or Ctrl+C to abort.
Affect(class-cnt:1 , method-cnt:1) cost in 332 ms.
ts=2019-06-04 11:38:06; [cost=2.75218ms] result=@HandlerExecutionChain[
    logger=@SLF4JLocationAwareLog[org.apache.commons.logging.impl.SLF4JLocationAwareLog@665c08a],
    handler=@HandlerMethod[public com.example.demo.arthas.user.User com.example.demo.arthas.user.UserController.findUserById(java.lang.Integer)],
    interceptors=null,
    interceptorList=@ArrayList[isEmpty=false;size=2],
    interceptorIndex=@Integer[-1],
]
</code></pre>
<ul>
<li>watch 命令定义了4个观察事件点，即 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后</li>
<li>4个观察事件点 -b、-e、-s 默认关闭，-f 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</li>
<li>这里要注意方法入参和方法出参的区别，有可能在中间被修改导致前后不一致，除了 -b 事件点 params 代表方法入参外，其余事件都代表方法出参</li>
<li>当使用 -b 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在</li>
</ul>
<h2 id="参考资料" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="header-mark"></a>参考资料</h2><p><a href="https://alibaba.github.io/arthas/commands.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
]]></description>
</item></channel>
</rss>
