<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Linux,shell,">





  <link rel="alternate" href="/atom.xml" title="plantegg" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="最牛B的Linux Shell命令引言Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。 本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑">
<meta name="keywords" content="Linux,shell">
<meta property="og:type" content="article">
<meta property="og:title" content="最牛B的Linux Shell命令">
<meta property="og:url" content="https://plantegg.github.io/2017/01/01/top_linux_commands/index.html">
<meta property="og:site_name" content="plantegg">
<meta property="og:description" content="最牛B的Linux Shell命令引言Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。 本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2024-11-20T07:08:06.862Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="最牛B的Linux Shell命令">
<meta name="twitter:description" content="最牛B的Linux Shell命令引言Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。 本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://plantegg.github.io/2017/01/01/top_linux_commands/">





  <title>最牛B的Linux Shell命令 | plantegg</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">plantegg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">java tcp mysql performance network docker Linux</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/01/01/top_linux_commands/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="twitter @plantegg">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">最牛B的Linux Shell命令</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T17:30:03+08:00">
                2017-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="最牛B的Linux-Shell命令"><a href="#最牛B的Linux-Shell命令" class="headerlink" title="最牛B的Linux Shell命令"></a>最牛B的Linux Shell命令</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。</p>
<p>本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑了。</p>
<h2 id="1-以sudo运行上条命令"><a href="#1-以sudo运行上条命令" class="headerlink" title="1.以sudo运行上条命令"></a>1.以sudo运行上条命令</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>sudo</strong> <strong>!!</strong></th>
</tr>
</thead>
</table>
<p>大家应该都知sudo，不解释。但通常出现的情况是，敲完命令执行后报错才发现忘了sudo。这时候，新手用户就会：按上箭头，按左箭头，盯着光标回到开始处，输入sudo，回车；高手用户就蛋定多了，按Ctrl-p，按Ctrl-a，输入sudo，回车。</p>
<p>这里介绍这个是天外飞仙级别的，对，就直接sudo !!。</p>
<p>当然这几种解决方式效果是完全一样的，只是款不一样，嗯，不解释。</p>
<p>两个感叹号其实是bash的一个特性，称为事件引用符（event designators）。!!其实相当于!-1，引用前一条命令，当然也可以!-2，!-50。默认情况下bash会在~&#x2F;.bash_history文件内记录用户执行的最近500条命令，history命令可以显示这些命令。</p>
<p>关于事件引用符的更多用法可以深入阅读<a href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/" target="_blank" rel="noopener">The Definitive Guide to Bash Command Line History</a>。</p>
<h2 id="2-以HTTP方式共享当前文件夹的文件"><a href="#2-以HTTP方式共享当前文件夹的文件" class="headerlink" title="2.以HTTP方式共享当前文件夹的文件"></a>2.以HTTP方式共享当前文件夹的文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ python -m  SimpleHTTPServer 8080</th>
</tr>
</thead>
</table>
<p>这命令启动了Python的SimpleHTTPServer模块，考虑到Python在绝大多数的Linux发行版当中都默认安装，所以这个命令很可能是最简单的跨平台传文件的方法。</p>
<p>命令执行后将在本机8000端口开放HTTP服务，在其他能访问本机的机器的浏览器打开ttp:&#x2F;&#x2F;ip:8000即打开一个目录列表，点击即可下载。</p>
<p>python3的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#最近一天修改的md文档</span><br><span class="line">find . -maxdepth 1 -type f -mtime -1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec ls -lh &quot;&#123;&#125;&quot; \;</span><br><span class="line"></span><br><span class="line">find . -size 0  -type f -exec ls -lh &quot;&#123;&#125;&quot; \;</span><br><span class="line"></span><br><span class="line">find . -maxdepth 1 -type f -mtime -2 -name &quot;*margin*&quot; -exec mv &quot;&#123;&#125;&quot; /tmp/img/ \;</span><br><span class="line"></span><br><span class="line">#clean the big file, but exclude spill dir</span><br><span class="line">sudo find /home/admin/ -not -path &quot;*/spill/*&quot; -type f -size +3G -exec cp /dev/null &#123;&#125; \;</span><br><span class="line">sudo find /home/admin/ -type f -name &quot;*.hprof&quot; -mtime +1 -exec rm -f &#123;&#125; \;</span><br><span class="line">#clean the spill temp file which before 7 days ago</span><br><span class="line">sudo find /home/admin/ -type f -mtime +7 -exec cp /dev/null &#123;&#125; \;</span><br><span class="line">sudo find /home/admin/logs/ -type f -mtime +7 -exec rm -f &#123;&#125; \;</span><br><span class="line">sudo find /var/log/ -type f -size +500M -exec cp /dev/null &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">// -mindepth 1 可以忽略当前目录的&quot;.&quot; </span><br><span class="line">find . -mindepth 1 -maxdepth 1 -type d -mtime -50</span><br><span class="line"></span><br><span class="line">#备份匹配的文件</span><br><span class="line">find . -name &apos;*.ibd&apos; | grep tpcc1000 | grep -v mysql_global | xargs -I&#123;&#125; cp --path &#123;&#125; /tmp/bak/</span><br><span class="line"></span><br><span class="line">#将yaml 备份，保留目录结构</span><br><span class="line">find . -name &apos;*.yaml&apos; | xargs -I&#123;&#125; cp --path &#123;&#125; /tmp/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find $srcDir -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec ls -lh &quot;&#123;&#125;&quot; \;</span><br><span class="line"></span><br><span class="line">find $srcDir -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec cp &quot;&#123;&#125;&quot; ./source/_posts/ \;</span><br><span class="line"></span><br><span class="line">#sudo find /media/sf_D_DRIVE/case/ -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -print -exec cp &quot;&#123;&#125;&quot; ./source/_posts/ \;</span><br><span class="line"></span><br><span class="line">cat的时候输出文件名：</span><br><span class="line">find . -type f -print -exec cat &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>xargs 参数：</p>
<blockquote>
<p>-I [replace-str]：将xargs的输出每一项参数，单独赋值给后面的命令，参数需要用指定的代替字符串replace-str代替，也就是说replace-str不可缺省，必须显示指明，可以使用{} $ @等符号，其主要作用是<strong>当xargs command后有多个参数时，调整参数位置</strong></p>
</blockquote>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>默认配置文件：<del>&#x2F;.toprc （on Ubuntu, it is *</del>&#x2F;.config&#x2F;procps&#x2F;toprc*）</p>
<p>增加列：f (此时可以调整用 → 选择列并调整位置， 此时也有4个窗口可以选择)</p>
<p>按node展示cpu：2(3 选择需要展示的node)</p>
<p>按core展示cpu: 1</p>
<p>切换颜色：z (有4个窗口可以选择，按 g 可以选择1-4)</p>
<p>配置颜色: Z </p>
<p><strong>V</strong> 切换成森林视图，也就是展示进程父子关系</p>
<p>保存配置: W</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dG9wJ3MgQ29uZmlnIEZpbGUgKExpbnV4IHByb2Nlc3NlcyB3aXRoIHdpbmRvd3MpCklkOmksIE1vZGVfYWx0c2NyPTAsIE1vZGVfaXJpeHBzPTEsIERlbGF5X3RpbWU9My4wLCBDdXJ3aW49MApDcHUJZmllbGRzY3VyPaWmqLWztLu9wMS3urg5xScpKissLS4vMDEyNjw+P0FCQ0ZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWoKCXdpbmZsYWdzPTE5NTM4MCwgc29ydGluZHg9MTgsIG1heHRhc2tzPTAsIGdyYXBoX2NwdXM9MCwgZ3JhcGhfbWVtcz0wCglzdW1tY2xyPTQsIG1zZ3NjbHI9MSwgaGVhZGNscj0zLCB0YXNrY2xyPTQKTWVtCWZpZWxkc2N1cj2lu73AvMPBws3OJjk3uigzNEQnxSkqKywtLi8wMTI1Njg+P0ZHSElKS0xPUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqCgl3aW5mbGFncz0xOTUzODAsIHNvcnRpbmR4PTIxLCBtYXh0YXNrcz0wLCBncmFwaF9jcHVzPTAsIGdyYXBoX21lbXM9MAoJc3VtbWNscj02LCBtc2dzY2xyPTYsIGhlYWRjbHI9MywgdGFza2Nscj02ClNjaAlmaWVsZHNjdXI9pTo7PD0+P0BBTUJOQ7WztMfEtre5xcYmJygpKissLS4vMDEyOEhJSktMT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpagoJd2luZmxhZ3M9MTk0ODY4LCBzb3J0aW5keD0wLCBtYXh0YXNrcz0wLCBncmFwaF9jcHVzPTAsIGdyYXBoX21lbXM9MAoJc3VtbWNscj01LCBtc2dzY2xyPTUsIGhlYWRjbHI9MywgdGFza2Nscj01CkNncAlmaWVsZHNjdXI9paanqCowOTc6RCkrLC0uLzEyMzQ1Njg7PD0+P0BBQkNGR8hJSktMTU5P0NHS09TVxVZXWFlaW1xdXl9gYWJjZGVmZ2hpagoJd2luZmxhZ3M9MTk0ODY4LCBzb3J0aW5keD0wLCBtYXh0YXNrcz0wLCBncmFwaF9jcHVzPTAsIGdyYXBoX21lbXM9MAoJc3VtbWNscj0yLCBtc2dzY2xyPTMsIGhlYWRjbHI9MywgdGFza2Nscj0yCkZpeGVkX3dpZGVzdD0wLCBTdW1tX21zY2FsZT0wLCBUYXNrX21zY2FsZT0wLCBaZXJvX3N1cHByZXNzPTAKCnBpcGUJTmV0RmlsZXMJbHNvZiAtYSAtbCAtbiAtUCAtaTQgLXAgJWQgMj4mMQpwaXBlCU9wZW5GaWxlcwlsc29mIC1hIC1sIC1uIC1QIC1wICVkIDI+JjEKZmlsZQlOVU1BSW5mbwkvcHJvYy8lZC9udW1hX21hcHMK</span><br></pre></td></tr></table></figure>

<h2 id="xargs-传参数"><a href="#xargs-传参数" class="headerlink" title="xargs 传参数"></a>xargs 传参数</h2><blockquote>
<p>ls &#x2F;xx | xargs -t -I{}  cp {} &#x2F;tmp&#x2F;{}</p>
</blockquote>
<p>-t ： 打印内容，去掉\n之后的字符串</p>
<p>-I :  后面定义占位符，上例子是{}  ，后面命令行中可以多次使用占位符</p>
<p>挂载多台苹果的例子</p>
<blockquote>
<p> idevice_id -l|xargs -t -I{} mkdir {};idevice_id -l |xargs -t -I{} ifuse {} {}</p>
</blockquote>
<p>批量执行docker exec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible -i host.ini all -m shell -a &quot;docker ps -a | grep tpcc | grep dn | cut -d &apos; &apos; -f 1 | xargs  -I&#123;&#125; docker exec &#123;&#125; bash -c \&quot;myc -e &apos;shutdown&apos;\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>批量推送镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images |grep &quot;docker.io:5000&quot; | awk &apos;&#123; print $1&quot;:&quot;$2 &#125;&apos; | xargs -I &#123;&#125; docker push &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>vim中默认匹配：abc.*d 是贪婪匹配，也就是尽可能长地匹配，改用 abc.{-}d 匹配到第一个 d字符就结束</p>
<blockquote>
<p>贪婪模式是: .*</p>
<p>非贪婪模式是: .\{-}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\&#123;n,m&#125; Matches n to m of the preceding atom, as many as possible</span><br><span class="line">\&#123;n&#125; Matches n of the preceding atom</span><br><span class="line">\&#123;n,&#125; Matches at least n of the preceding atom, as many as possible</span><br><span class="line">\&#123;,m&#125; Matches 0 to m of the preceding atom, as many as possible</span><br><span class="line">\&#123;&#125; Matches 0 or more of the preceding atom, as many as possible (like *)</span><br><span class="line">*/\&#123;-*</span><br><span class="line">\&#123;-n,m&#125; matches n to m of the preceding atom, as few as possible</span><br><span class="line">\&#123;-n&#125; matches n of the preceding atom</span><br><span class="line">\&#123;-n,&#125; matches at least n of the preceding atom, as few as possible</span><br><span class="line">\&#123;-,m&#125; matches 0 to m of the preceding atom, as few as possible</span><br><span class="line">\&#123;-&#125; matches 0 or more of the preceding atom, as few as possibles</span><br></pre></td></tr></table></figure>

<p>grep 非贪婪匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep --color -P &quot;agHost.*?,&quot; test.table  //匹配 agHost后带有多个任意字符直到第一个 逗号 结束，-P表示用 perl 的匹配语法，而perl默认是不支持贪婪的</span><br><span class="line"></span><br><span class="line">grep --color -o -P &quot;agHost.*?,&quot; test.table  //-o 只打印匹配部分</span><br></pre></td></tr></table></figure>

<p>匹配数字至少4次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -E &quot;,rows=[0-9]&#123;4,&#125;&quot;</span><br><span class="line">grep -E &quot;[0-9]&#123;4,&#125;ms&quot; mongod.log</span><br></pre></td></tr></table></figure>

<h2 id="macOS-sed-删除行"><a href="#macOS-sed-删除行" class="headerlink" title="macOS sed 删除行"></a>macOS sed 删除行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查找匹配的行：|      |                               |</span><br><span class="line">grep -E &quot;\| [[:space:]]*\| [[:space:]]*\|&quot; top_linux_commands.md -B3</span><br><span class="line"></span><br><span class="line">//删除行 -i &quot;.bak&quot;是直接操作文件并添加.bak作为备份文件名称，如果不需要备份文件，则使用-i &quot;&quot;</span><br><span class="line">sed -i &apos;&apos; -e  &apos;/\| [[:space:]]*\| [[:space:]]*\|/d&apos;  top_linux_commands.md</span><br><span class="line"></span><br><span class="line">//先备份文件为.bak, 再删除行 -i &quot;.bak&quot;是添加.bak作为备份文件名称</span><br><span class="line">sed -i &apos;.bak&apos; &apos;s/\| [[:space:]]*\| [[:space:]]*\|/d&apos;  top_linux_commands.md</span><br></pre></td></tr></table></figure>

<h2 id="ps-查看进程"><a href="#ps-查看进程" class="headerlink" title="ps 查看进程"></a>ps 查看进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -Tfp pid // -T 展开进程下的线程 -f full -p pid</span><br></pre></td></tr></table></figure>

<h2 id="循环按行处理"><a href="#循环按行处理" class="headerlink" title="循环按行处理"></a>循环按行处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while  read i ; do echo $i ; done &lt;./prometheus.list</span><br></pre></td></tr></table></figure>

<h2 id="3-在以普通用户打开的vim当中保存一个root用户文件"><a href="#3-在以普通用户打开的vim当中保存一个root用户文件" class="headerlink" title="3.在以普通用户打开的vim当中保存一个root用户文件"></a>3.在以普通用户打开的vim当中保存一个root用户文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>:<strong>w</strong> <strong>!sudo</strong> <strong>tee</strong> <strong>%</strong></th>
</tr>
</thead>
</table>
<p>这题目读起来纠结，其实是很常见的，常常忘记了sudo就直接用vim编辑&#x2F;etc内的文件，（不过也不一定，vim发现保存的文件无法保存时候会提示）等编辑好了，保存时候才发现没权限。曲线方法是先保存个临时文件，退出后再sudo cp回去。不过实际上在vim里面可以直接完成这个过程的，命令就是如此。</p>
<p>查阅vim的文档（输入:help :w），会提到命令:w!{cmd}，让vim执行一个外部命令{cmd}，然后把当前缓冲区的内容从stdin传入。</p>
<p>tee是一个把stdin保存到文件的小工具。</p>
<p>而%，是vim当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。</p>
<p>所以执行这个命令，就相当于从vim外部修改了当前编辑的文件，好完工。</p>
<h2 id="4-切换回上一个目录"><a href="#4-切换回上一个目录" class="headerlink" title="4.切换回上一个目录"></a>4.切换回上一个目录</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>cd</strong> -</th>
</tr>
</thead>
</table>
<p>应该不少人都知道这个，横杆-代表上一个目录的路径。</p>
<p>实际上cd -就是cd $OLDPWD的简写，bash的固定变量$OLDPWD总保存着之前一个目录的路径。</p>
<p>相对地，$PWD总保存着当前目录的路径。这些变量在编写shell脚本时候相当有用。</p>
<h2 id="5-替换上一条命令中的一个短语"><a href="#5-替换上一条命令中的一个短语" class="headerlink" title="5.替换上一条命令中的一个短语"></a>5.替换上一条命令中的一个短语</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ ^foo^bar^</th>
</tr>
</thead>
</table>
<p>又是另外一个事件引用符（event designator），可以把上一条命令当中的foo替换成bar。</p>
<p>在需要重复运行调试一道长长的命令，需要测试某个参数时候，用这个命令会比较实用；但多数人会首先选择按上箭头提出上道命令，再移动光标去修改某参数，这样更直观，但效率上就不够使用引用符高，而且在脚本中用这个方法可以简化很多。</p>
<p>这道命令的原始样式应该是这样的:</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>!!</strong>:s**&#x2F;<strong>foo</strong>&#x2F;<strong>bar</strong>&#x2F;**</th>
</tr>
</thead>
</table>
<p>本文一开始介绍过!!，后面的一段大家应该很熟悉，vim、sed的替换操作都是这样的语法。</p>
<p>关于事件引用符的更多用法可以深入阅读<a href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/" target="_blank" rel="noopener">The Definitive Guide to Bash Command Line History</a></p>
<h2 id="6-快速备份一个文件"><a href="#6-快速备份一个文件" class="headerlink" title="6.快速备份一个文件"></a>6.快速备份一个文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>cp</strong>  filename**{<strong>,.bak</strong>}**</th>
</tr>
</thead>
</table>
<p>这道命令把filename文件拷贝成filename.bak，大家应该在一些比较复杂的安装教程里面见过这样的用法。其原理就在于bash对大括号的展开操作，filename{,.bak}这一段会被展开成filename filename.bak再传给cp，于是就有了备份的命令了。</p>
<p>大括号在bash里面是一个排列的意义，可以试试这个：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>echo</strong> <strong>{<strong>a,b,c</strong>}{<strong>a,b,c</strong>}{<strong>a,b,c</strong>}</strong></th>
</tr>
</thead>
</table>
<p>将输出三个集合的全排列:</p>
<p>aaa aab aac aba abb abc aca acb acc</p>
<p>baa bab bac bba bbb bbc bca bcb bcc</p>
<p>caa cab cac cba cbb cbc cca ccb ccc</p>
<p>关于shell当中的集合操作，可深入阅读<a href="http://www.catonmat.net/blog/set-operations-in-unix-shell/" target="_blank" rel="noopener">“Set Operations in the Unix Shell”</a></p>
<h2 id="7-免密码ssh登录主机"><a href="#7-免密码ssh登录主机" class="headerlink" title="7.免密码ssh登录主机"></a>7.免密码ssh登录主机</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ ssh-copy-id remote-machine</th>
</tr>
</thead>
</table>
<p>这个命令把当前用户的公钥串写入到远程主机的~&#x2F;.ssh&#x2F;authorized_keys内，这样下次使用ssh登录的时候，远程主机就直接根据这串密钥完成身份校验，不再询问密码了。前提是你当前用户有生成了公钥，默认是没有的，先执行ssh-keygen试试吧！</p>
<p>这个命令如果用手工完成，是这样的：</p>
<table>
<thead>
<tr>
<th>1  2  3</th>
<th>your-machine$ scp  ~&#x2F;.ssh&#x2F;identity.pub  remote-machine:  your-machine$ ssh  remote-machine  remote-machine$ cat  identity.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</th>
</tr>
</thead>
</table>
<p>如果你想删掉远程主机上的密钥，直接打开authorized_keys，搜索你的用户名，删除那行，即可。</p>
<h2 id="8-抓取Linux桌面的视频"><a href="#8-抓取Linux桌面的视频" class="headerlink" title="8.抓取Linux桌面的视频"></a>8.抓取Linux桌面的视频</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>ffmpeg</strong> -f x11grab -s  wxga -r 25  -i :0.0 -sameq **&#x2F;<strong>tmp</strong>&#x2F;**out.mpg</th>
</tr>
</thead>
</table>
<p>我们在一些视频网站上看到别人的3D桌面怎么怎么酷的视频，通常就是这么来的，ffmpeg可以直接解码X11的图形，并转换到相应输出格式。</p>
<p>ffmpeg的通常用法是，根据一堆参数，输出一个文件，输出文件通常放最后，下面解析下几个参数：</p>
<p>-f x11grab 指定输入类型。因为x11的缓冲区不是普通的视频文件可以侦测格式，必须指定后ffmpeg才知道如何获得输入。</p>
<p>-s wxga 设置抓取区域的大小。wxga是1366*768的标准说法，也可以换成-s 800×600的写法。</p>
<p>-r 25 设置帧率，即每秒抓取的画面数。</p>
<p>-i :0.0 设置输入源，本地X默认在0.0</p>
<p>-sameq 保持跟输入流一样的图像质量，以用来后期处理。</p>
<p>至于其他ffmpeg的用法，可以参考下面两篇文章：</p>
<p>·    <a href="http://www.catonmat.net/blog/how-to-extract-audio-tracks-from-youtube-videos/" target="_blank" rel="noopener">How to Extract Audio Tracks from YouTube Videos</a></p>
<p>·    <a href="http://www.catonmat.net/blog/converting-youtube-flvs-to-a-better-format-with-ffmpeg" target="_blank" rel="noopener">Converting YouTube Flash Videos to a Better Format with ffmpeg</a></p>
<p>后记</p>
<p>说Shell是一种编程语言，可能有些尴尬，虽然很多人每天都在用Shell，但从来没见它荣登TIOBE编程语言排行榜之类的，可以说毫无名分，因为很多用户没意识到它是一种语言，只当做这是一个能够很好完成任务的工具，基本得理所当然，就好像GUI程序的菜单、按钮一样。</p>
<p>掌握Shell，通常能够让任务在数秒钟内完成，这就让Shell跟C、Perl、Python这些语言区别开来，没人否认后者更能胜任更多的任务，但是他们是在不同的层面上去做，Shell依赖大量的系统组件黏合调用，而后者依赖各种库，各所擅长不同的应用领域，比喻就是，Shell是混凝土，可以很方便地粘合一些建筑组件而成为稳固的高楼大厦；但同样是粘合剂，粘玻璃窗、粘书报、粘皮鞋，混凝土是绝对不合适的，Shell并不擅长一些细致操作，比如它连浮点运算都不支持，更别提什么图形运算什么的。但这并不妨碍Shell来帮我们完成很多粗重任务。</p>
<p>Shell的工作方式，大多数入门用户会觉得枯燥难学，而所谓的经典教材也离不开《Advanced Bash-Scripting》、《Bash Guide for Beginners》，但类似本文这样的一些“雕虫小技”因为难登大雅之堂绝不会收录进去。这情况如果象国外一些unix用户比较多的地方会有很好改善，即使是新手，偶尔看看别人的操作都能“偷师”一手，我编译本系列文章其实也就希望稍微改善一下这个状况。</p>
<h2 id="1-用你最喜欢的编辑器来敲命令"><a href="#1-用你最喜欢的编辑器来敲命令" class="headerlink" title="1.用你最喜欢的编辑器来敲命令"></a>1.用你最喜欢的编辑器来敲命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>command</strong> <strong>&lt;**CTRL-x  CTRL-e**&gt;</strong></th>
</tr>
</thead>
</table>
<p>在已经敲完的命令后按<ctrl-x ctrl-e>，会打开一个你指定的编辑器（比如vim，通过环境变量$EDITOR指定），里面就是你刚输入的命令，然后爱怎么编辑就怎么编辑吧，特别是那些参数异常复杂的程序，比如mencoder&#x2F;ffmpeg，一个命令动辄3、4行的，要修改其中的参数，这个方法最合适不过了，保存退出后自动执行这个程序。</ctrl-x></p>
<p>实际上这是<a href="http://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="noopener">readline库</a>的功能，在默认情况下，bash使用的是emacs模式的命令行操作方式，<ctrl-x ctrl-e>是调用这个功能的一个绑定。如果你习惯使用vi模式，按<esc v>可以实现同样功能。</esc></ctrl-x></p>
<p>如果你喜欢别的编辑器，可以在~&#x2F;.bashrc里面放上比如export EDITOR&#x3D;nano的命令。</p>
<p>另外一个修改命令的方法是使用fc命令（Fix Command），在编辑器里面打开上一句命令。我们的<a href="http://www.isspy.com/most_useful_linux_commands_1/" target="_blank" rel="noopener">第一辑连载</a>提过一个^foo^bar^命令可以用fc来实现：fc -s foo&#x3D;bar。</p>
<h2 id="2-清空或创建一个文件"><a href="#2-清空或创建一个文件" class="headerlink" title="2.清空或创建一个文件"></a>2.清空或创建一个文件</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>&gt;</strong> file.txt</th>
</tr>
</thead>
</table>
<p>&gt;在shell里面是标准输出重定向符，即把（前部个命令的）命令行输出转往一个文件内，但这里没有“前部命令”，输出为空，于是就覆盖（或创建）成一个空文件了。</p>
<p>有些脚本的写法是:&gt;file.txt，因为:是bash默认存在的空函数。</p>
<p>单纯创建文件也可以用$touch file.txt，touch本来是用作修改文件的时间戳，但如果文件不存在，就自动创建了。</p>
<h2 id="3-用ssh创建端口转发通道"><a href="#3-用ssh创建端口转发通道" class="headerlink" title="3.用ssh创建端口转发通道"></a>3.用ssh创建端口转发通道</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -N  -L2001:remotehost:80 user**@**somemachine</th>
</tr>
</thead>
</table>
<p>这个命令在本机打开了2001端口，对本机2001端口的请求通过somemachine作为跳板，转到remotehost的80端口上。</p>
<p>实现效果跟术语反向代理是相似的，实际上就是端口转发，注意上面的描述涉及了3台主机，但当然somemachine可以变成localhost。</p>
<p>这个命令比较抽象，但有时候是很有用的，比如因为众所周知的原因国内的IP的80端口无法使用，又或者公司的防火墙只给外网开了ssh端口，需要访问内部服务器一个web应用，以及需要访问某些限定了来源IP的服务，就可以用上这个方法了。</p>
<p>举一个具体例子，运行：</p>
<table>
<thead>
<tr>
<th>1  2</th>
<th><strong>ssh</strong> -f -N -L  0.0.0.0:443:twitter.com:443 shell.cjb.net  <strong>ssh</strong> -f -N -L  0.0.0.0:80:twitter.com:80 shell.cjb.net</th>
</tr>
</thead>
</table>
<p>然后在&#x2F;etc&#x2F;hosts里面添加127.0.0.1 twitter.com，好吧剩下的你懂的。</p>
<p>当然通常做这个功能的反向代理，应该要用squid、nginx之类，ssh就算是轻量级的尝试吧！</p>
<h2 id="4-重置终端"><a href="#4-重置终端" class="headerlink" title="4.重置终端"></a>4.重置终端</h2><table>
<thead>
<tr>
<th>1</th>
<th>reset</th>
</tr>
</thead>
</table>
<p>如果你试过不小心cat了某个二进制文件，很可能整个终端就傻掉了，可能不会换行，没法回显，大堆乱码之类的，这时候敲入reset回车，不管命令有没有显示，就能回复正常了。</p>
<p>实际上reset命令只是输出了一些特殊字符，我们看BusyBox里面最简单的reset程序的实现：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>printf(“<strong>\033</strong>c<strong>\033</strong>(K<strong>\033</strong>[J<strong>\033</strong>[0m<strong>\033</strong>[?25h”);</th>
</tr>
</thead>
</table>
<p>输出的这些字符对Shell是有特殊意义的：</p>
<p>·    \033c: “ESC c” – 发送重置命令;</p>
<p>·    \033(K: “ESC ( K” – 重载终端的字符映射;</p>
<p>·    \033[J: “ESC [ J” – 清空终端内容;</p>
<p>·    \033[0m: “ESC [ 0 m” – 初始化字符显示属性;</p>
<p>·    \033[?25h: “ESC [ ? 25 h” – 让光标可见;</p>
<p>其中<em>字符显示属性</em>经常用来设定打印字符的颜色等，可参考<a href="http://linuxshellaccount.blogspot.com/2008/03/using-color-in-linux-or-unix-shell.html" target="_blank" rel="noopener">这个博文</a>。</p>
<h2 id="5-在午夜的时候执行某命令"><a href="#5-在午夜的时候执行某命令" class="headerlink" title="5.在午夜的时候执行某命令"></a>5.在午夜的时候执行某命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>echo</strong> cmd <strong>|</strong> at  midnight</th>
</tr>
</thead>
</table>
<p>说的就是at这个组件，通常跟cron相提并论，不过at主要用于定时一次性任务，而cron定时周期性任务。</p>
<p>at的参数比较人性化，跟英语语法一样，可以tomorrow, next week之类的，详细的查看手册man at。</p>
<h2 id="6-远程传送麦克风语音"><a href="#6-远程传送麦克风语音" class="headerlink" title="6.远程传送麦克风语音"></a>6.远程传送麦克风语音</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>dd</strong> if&#x3D;**&#x2F;<strong>dev</strong>&#x2F;<strong>dsp  <strong>|</strong> <strong>ssh</strong>  username</strong>@<strong>host <strong>dd</strong> of&#x3D;</strong>&#x2F;<strong>dev</strong>&#x2F;**dsp</th>
</tr>
</thead>
</table>
<p>没错就是实现一个喊话器的功能。</p>
<p>&#x2F;dev&#x2F;dsp是Linux下声卡的文件映射（Digital Signal Proccessor），从其中读数据就是录音，往里面写数据就是播放，相当简单！</p>
<p>dd是常用的数据拷贝程序，如果不同时指定if、of，就直接使用stdin&#x2F;stdout来传输。</p>
<p>如果你没有远程主机，可以试试这样：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>dd</strong> if&#x3D;**&#x2F;<strong>dev</strong>&#x2F;<strong>dsp  of&#x3D;</strong>&#x2F;<strong>dev</strong>&#x2F;**dsp</th>
</tr>
</thead>
</table>
<p>直接回放麦克风的声音，只是有一点延时。</p>
<p>但是如果有别的程序正在使用声卡，这个方法就不凑效了，因为一般的声卡都不允许多个音频流同时处理，可以借用alsa组件的工具，arecord跟aplay:</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>arecord</strong> <strong>|</strong> <strong>ssh</strong> username**@**host  <strong>aplay</strong></th>
</tr>
</thead>
</table>
<p>本地回放就是：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>arecord</strong> <strong>|</strong> <strong>aplay</strong></th>
</tr>
</thead>
</table>
<p>如果你想吓吓别人：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>cat</strong> **&#x2F;<strong>dev</strong>&#x2F;<strong>urandom <strong>|</strong>  <strong>ssh</strong> username</strong>@**host <strong>aplay</strong></th>
</tr>
</thead>
</table>
<h2 id="7-映射一个内存目录"><a href="#7-映射一个内存目录" class="headerlink" title="7.映射一个内存目录"></a>7.映射一个内存目录</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>mount</strong> -t tmpfs -o size&#x3D;1024m  tmpfs **&#x2F;<strong>mnt</strong>&#x2F;**ram</th>
</tr>
</thead>
</table>
<p>这个命令开了一块1G内存来当目录用。不过放心，如果里面没文件，是不会占用内存的，用多少占多少。</p>
<p>不过一般来说没必要手动挂载，因为多数发行版都会在fstab内预留了一个内存目录，挂载在&#x2F;dev&#x2F;shm，直接使用即可；</p>
<p>最常见的用途是用内存空间来放Firefox的配置，可以让慢吞吞的FF快很多，参见Shellex的博文：<a href="http://shellex.info/speeding-up-firefox-with-tmpfs/" target="_blank" rel="noopener">用tmpfs让Firefox在内存中飞驰</a>，以及后来的改进：<a href="http://shellex.info/speeding-up-firefox-with-tmpfs-ii/" target="_blank" rel="noopener">用tmpfs让Firefox在内存中飞驰II</a>，其中提到的脚本来自<a href="http://www.linuxized.com/2009/05/speeding-up-firefox-with-tmpfs-and-automatic-rsync/" target="_blank" rel="noopener">speeding up firefox with tmpfs and automatic rsync</a>。</p>
<p>那个破烂LinuxQQ也可以用这个方法，减少因为大量磁盘IO导致的问题。</p>
<h2 id="8-用diff对比远程文件跟本地文件"><a href="#8-用diff对比远程文件跟本地文件" class="headerlink" title="8.用diff对比远程文件跟本地文件"></a>8.用diff对比远程文件跟本地文件</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> user**@**host <strong>cat</strong> **&#x2F;<strong>path</strong>&#x2F;<strong>to</strong>&#x2F;**remotefile  <strong>|</strong> <strong>diff</strong>  **&#x2F;<strong>path</strong>&#x2F;<strong>to</strong>&#x2F;**localfile -</th>
</tr>
</thead>
</table>
<p>diff通常的用法是从参数读入两个文件，而命令里面的-则是指从stdin读入了。</p>
<p>善用ssh可以让web开发减少很多繁琐，还有比如sshfs，可以从<strong>编辑</strong>**-<strong><strong>上传</strong></strong>-<strong><strong>编辑</strong></strong>-**<strong>上传</strong>的人工循环里面解脱出来。</p>
<h2 id="9-查看系统中占用端口的进程"><a href="#9-查看系统中占用端口的进程" class="headerlink" title="9.查看系统中占用端口的进程"></a>9.查看系统中占用端口的进程</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>netstat</strong> -tulnp</th>
</tr>
</thead>
</table>
<p>Netstat是很常用的用来查看Linux网络系统的工具之一，这个参数可以背下来：</p>
<p>·    -t: 显示TCP链接信息</p>
<p>·    -u: 显示UDP链接信息</p>
<p>·    -l: 显示监听状态的端口</p>
<p>·    -n: 直接显示ip，不做名称转换</p>
<p>·    -p: 显示相应的进程PID以及名称（要root权限）</p>
<p>如果要查看关于sockets更详细占用信息等，可以使用lsof工具。</p>
<h2 id="1-更友好的显示当前挂载的文件系统"><a href="#1-更友好的显示当前挂载的文件系统" class="headerlink" title="1. 更友好的显示当前挂载的文件系统"></a>1. 更友好的显示当前挂载的文件系统</h2><p>| <code>1</code>  | <code>**mount** **|** column -t</code> |<br>| —- | ————————— |</p>
<p>这条命令适用于任何文件系统，column 用于把输出结果进行列表格式化操作，这里最主要的目的是让大家熟悉一下 columnt 的用法。 下面是单单使用 mount 命令的结果：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>$ **mount**`` ``**/**dev**/**root on **/** **type** ext3 **(**rw**)**``**/**proc on **/**proc **type** proc **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3 **(**rw,noatime**)**</code></th>
</tr>
</thead>
</table>
<p>而加了 column -t 命令后就成为这样了：</p>
<p>| <code>1``2``3``4``5</code> | <code>$ **mount** **|** column -t`` ``**/**dev**/**root on **/** **type** ext3 **(**rw**)**``**/**proc on **/**proc **type** proc **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3 **(**rw,noatime**)**</code> |<br>| ————— | ———————————————————— |</p>
<p>另外你可加上列名称来改善输出结果</p>
<p>| <code>1``2``3``4``5``6</code> | <code>$ **(echo** &quot;DEVICE - PATH - TYPE FLAGS&quot; **&amp;&amp;** **mount)** **|** column -t`` ``DEVICE          -  PATH  -   TYPE  FLAGS``**/**dev**/**root         on **/**   **type** ext3  **(**rw**)**``**/**proc           on **/**proc **type** proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3  **(**rw,noatime**)**</code> |<br>| —————— | ———————————————————— |</p>
<p>列2和列4并不是很友好，我们可以用 awk 来再处理一下</p>
<p>| <code>1``2``3``4``5``6</code> | <code>$ **(echo** &quot;DEVICE PATH TYPE FLAGS&quot; **&amp;&amp;** **mount** **|** **awk** &#39;$2=$4=&quot;&quot;;1&#39;**)** **|** column -t`` ``DEVICE          PATH  TYPE  FLAGS``**/**dev**/**root         **/**   ext3  **(**rw**)**``**/**proc           **/**proc proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home **/**home ext3  **(**rw,noatime**)**</code> |<br>| —————— | ———————————————————— |</p>
<p>最后我们可以设置一个别名，为 nicemount</p>
<p>| <code>1</code>  | <code>$ nicemount**()** **{** **(echo** &quot;DEVICE PATH TYPE FLAGS&quot; **&amp;&amp;** **mount** **|** **awk** &#39;$2=$4=&quot;&quot;;1&#39;**)** **|** column -t; **}**</code> |<br>| —- | ———————————————————— |</p>
<p>试一下</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6</code></th>
<th><code>$ nicemount`` ``DEVICE          PATH  TYPE  FLAGS``**/**dev**/**root         **/**   ext3  **(**rw**)**``**/**proc           **/**proc proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home **/**home ext3  **(**rw,noatime**)**</code></th>
</tr>
</thead>
</table>
<h2 id="2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”"><a href="#2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”" class="headerlink" title="2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”"></a>2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**!!**:gs**/**foo**/**bar</code></th>
</tr>
</thead>
</table>
<p><code>!!</code> 表示重复执行上一条命令，并用 <code>:gs/foo/bar</code> 进行替换操作。 关于 <code>!!</code> 这个用法在<a href="http://www.isspy.com/most_useful_linux_commands_1/" target="_blank" rel="noopener">前一篇文章中</a>已有详细的介绍。</p>
<h2 id="3-实时某个目录下查看最新改动过的文件"><a href="#3-实时某个目录下查看最新改动过的文件" class="headerlink" title="3. 实时某个目录下查看最新改动过的文件"></a>3. 实时某个目录下查看最新改动过的文件</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**watch** -d -n 1 &#39;df; ls -FlAt /path&#39;</code></th>
</tr>
</thead>
</table>
<p>watch 是实时监控工具，-d 参数会高亮显示变化的区域，-n 1 参数表示刷新间隔为 1 秒。 df; ls -FlAt &#x2F;path 运行了两条命令，df 是输出磁盘使用情况，<code>ls -FlAt</code> 则列出 &#x2F;path 下面的所有文件。 ls -FlAt 的参数详解：</p>
<p>·    -F 在文件后面加一个文件符号表示文件类型，共有 <em>&#x2F;&#x3D;&gt;@|</em> <em>这几种类型，</em> 表示可执行文件，&#x2F; 表示目录，&#x3D; 表示接口( sockets) ，&gt; 表示门， @ 表示符号链接， | 表示管道。</p>
<p>·    -l 以列表方式显示</p>
<p>·    -A 显示 <code>.</code> 和 <code>..</code></p>
<p>·    -t 根据时间排序文件</p>
<h2 id="4-通过-SSH-挂载远程主机上的文件夹"><a href="#4-通过-SSH-挂载远程主机上的文件夹" class="headerlink" title="4. 通过 SSH 挂载远程主机上的文件夹"></a>4. 通过 SSH 挂载远程主机上的文件夹</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>sshfs name**@**server:**/**path**/**to**/**folder **/**path**/**to**/**mount**/**point</code></th>
</tr>
</thead>
</table>
<p>这条命令可以让你通过 SSH 加载远程主机上的文件系统为本地磁盘，前提是你需要安装 FUSE 及 sshfs 这两个软件。 <strong>译者注</strong>：关于 sshfs 实际上我之前写过一篇文章介绍过，详见<a href="http://wowubuntu.com/sshfs.html" target="_blank" rel="noopener">在 Ubuntu 上使用 sshfs 映射远程 ssh 文件系统为本地磁盘</a>。 卸载的话使用 fusermount 或 umount 命令：</p>
<table>
<thead>
<tr>
<th><code>1``2</code></th>
<th><code>$ fusermount -u **/**path**/**to**/**mount**/**point``*# umount /path/to/mount/point*</code></th>
</tr>
</thead>
</table>
<h2 id="5-通过-DNS-来读取-Wikipedia-的词条"><a href="#5-通过-DNS-来读取-Wikipedia-的词条" class="headerlink" title="5. 通过 DNS 来读取 Wikipedia 的词条"></a>5. 通过 DNS 来读取 Wikipedia 的词条</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**dig** +short txt .wp.dg.cx</code></th>
</tr>
</thead>
</table>
<p>这也许是最有趣的一条技巧了，David Leadbeater 创建了一个 <a href="https://dgl.cx/wikipedia-dns" target="_blank" rel="noopener">DNS 服务器</a>，通过它当你查询一个 TXT 记录类型时，会返回一条来自于 Wikipedia 的简短的词条文字，这是<a href="https://dgl.cx/2008/11/wpdns-pres/" target="_blank" rel="noopener">他的介绍</a>。 这里有一个样例，来查询 “hacker” 的含义：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8</code></th>
<th><code>$ **dig** +short txt hacker.wp.dg.cx`` ``&quot;Hacker may refer to: Hacker (computer security), someone involved``in computer security/insecurity, Hacker (programmer subculture), a``programmer subculture originating in the US academia in the 1960s,``which is nowadays mainly notable for the free software/” “open``source movement, Hacker (hobbyist), an enthusiastic home computer``hobbyist http://a.vu/w:Hacker&quot;</code></th>
</tr>
</thead>
</table>
<p>这里使用了 dig 命令，这是标准的用来查询 DNS 的系统管理工具，+short 参数是让其仅仅返回文字响应，txt 则是指定查询 TXT 记录类型。 更简单的做法是你可以为这个技巧创建一个函数：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>wiki**()** **{** **dig** +short txt $1.wp.dg.cx; **}**``*#**然后试试吧：*``wiki hacker`` ``&quot;Hacker may refer to: Hacker (computer security), …&quot;</code></th>
</tr>
</thead>
</table>
<p>如果你不想用 dig ，也可以用 host 命令：</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>host -t txt hacker.wp.dg.cx</code></th>
</tr>
</thead>
</table>
<p>另外在Twitter上看过某人的创意，用普通的dns来作为程序版本更新的查询服务器：设定域名<code>software-version-check.example.com</code>的A记录为<code>1.2.40.3</code>，对比自己的版本号，嗯，有更新了！</p>
<h2 id="6-用-Wget-的递归方式下载整个网站"><a href="#6-用-Wget-的递归方式下载整个网站" class="headerlink" title="6. 用 Wget 的递归方式下载整个网站"></a>6. 用 Wget 的递归方式下载整个网站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup wget --random-wait -nc -q -r -l 0 --reject=html -np -e robots=off -U Mozilla www.example.com &amp;</span><br></pre></td></tr></table></figure>

<p>参数解释： <em>–random-wait</em> <em>等待</em> <em>0.5</em> <em>到</em> <em>1.5</em> <em>秒的时间来进行下一次请求</em> -r 开启递归检索 <em>-e robots&#x3D;off</em> <em>忽略</em> <em>robots.txt</em> -U Mozilla 设置 User-Agent 头为 Mozilla 其它一些有用的参数：</p>
<p>·    –limit-rate&#x3D;20K 限制下载速度为 20K</p>
<p>·    -o logfile.txt 记录下载日志</p>
<p>·    -l 0 删除深度（默认为5）</p>
<p>·    -wait&#x3D;1h 每下载一个文件后等待1小时</p>
<p>-np 不下载父目录 </p>
<p>–reject&#x3D;html 不下载html</p>
<p>-nc 本地已有的不再下载</p>
<h2 id="7-复制最后使用的命令中的参数"><a href="#7-复制最后使用的命令中的参数" class="headerlink" title="7. 复制最后使用的命令中的参数"></a>7. 复制最后使用的命令中的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + . or ESC + . </span><br><span class="line">command + . //macOS</span><br></pre></td></tr></table></figure>

<p>这个快捷键只能工作于 shell 的 emacs 编辑模式，它可以从最后使用的命令行中复制参数到当前命令行中，下面是一个样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** c</code></th>
</tr>
</thead>
</table>
<p>你可以重复执行该快捷键，以便获取自已需要的参数， 以下是样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8``9``10</code></th>
<th><code>$ **echo** 1 2 3``1 2 3``$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** c`` ``$ **echo** again``$ **echo** 3</code></th>
</tr>
</thead>
</table>
<p>另外，假如你想指定第1个或第2个，或者是第 n 个参数的话，可以按 ALT + 1 (或 ESC + 1) 或 ALT + 2 (或 ESC +2) 这样形式的快捷键。 以下是样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8``9``10</code></th>
<th><code>$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** a``a`` ``$ **echo**``$ **echo** b``b</code></th>
</tr>
</thead>
</table>
<p>查看<a href="http://www.catonmat.net/blog/bash-emacs-editing-mode-cheat-sheet/" target="_blank" rel="noopener">Emacs Editing Mode Keyboard Shortcuts</a>一文获取更多类似的快捷键。</p>
<h2 id="8-执行一条命令但不保存到-history-中"><a href="#8-执行一条命令但不保存到-history-中" class="headerlink" title="8. 执行一条命令但不保存到 history 中"></a>8. 执行一条命令但不保存到 history 中</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>$ **command**</code></th>
</tr>
</thead>
</table>
<p>这条命令可运行于最新的 Bash shell 里，在其它 shell 中没测试过。 通过在命令行前面添加一个空格，就可以阻止这条命令被保存到 bash history (~&#x2F;.bash_history) 文件中，这个行为可以通过 $HISTIGNORE shell 变量来控制。我的设置是 HISTIGNORE&#x3D;”&amp;:[ ]*” ，表示不保存重复的命令到 history 中，并且不保存以空格开头的命令行。$HISTIGNORE 中的值以冒号分隔。 如果你的命令内包含密码，比如<code>mysqladmin</code>，不把它记录在历史当中是好主义。 深入了解的话，可进一步看此文<a href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/" target="_blank" rel="noopener">The Definitive Guide to Bash Command Line History</a></p>
<h2 id="9-显示当前目录中所有子目录的大小-du"><a href="#9-显示当前目录中所有子目录的大小-du" class="headerlink" title="9. 显示当前目录中所有子目录的大小 du"></a>9. 显示当前目录中所有子目录的大小 du</h2><table>
<thead>
<tr>
<th>sudo du –max-depth&#x3D;1 -BG &#x2F;&#x2F;单位 block-size G;  or  -BM MB</th>
<th>du -h –max-depth&#x3D;1</th>
</tr>
</thead>
</table>
<p>–max-depth&#x3D;1 参数可以让 du 命令显示当前目录下 1 级子目录的统计信息，当然你也可以把 1 改为 2 ，进一步显示 2 级子目录的统计信息，可以灵活运用。而 -h 参数则是以 Mb 、G 这样的单位来显示大小。 <strong>译者注</strong>：在此推荐一个小工具 ncdu ，可以更方便的达到此效果。</p>
<p> 按单位大小排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#du -sh * | sort -hr | head</span><br><span class="line">1.8T	anolis_yum</span><br><span class="line">1.6T	u02</span><br><span class="line">1.5T	os</span><br><span class="line">45G	drds_image</span><br><span class="line">23G	polarx</span><br><span class="line">8.3G	src</span><br><span class="line">7.9G	drds.pcap</span><br><span class="line">7.8G	root</span><br><span class="line">4.3G	core.24086</span><br><span class="line">3.5G	core.112462</span><br></pre></td></tr></table></figure>

<h2 id="10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序"><a href="#10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序" class="headerlink" title="10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序"></a>10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序</h2><p>| <code>1</code>  | <code>**ps** aux **|** **sort** -nk +4 **|** **tail**</code> |<br>| —- | ————————————————- |</p>
<p>显然这并不是最好的方法，但它确实用起还不错。 这是一个典型的管道应用，通过 ps aux 来输出到 sort 命令，并用 sort 排序列出 4 栏，再进一步转到 tail 命令，最终输出 10 行显示使用内存最多的进程情况。 假如想要发现哪个进程使用了大量内存的话，我通常会使用 htop 或 top 而非 ps 。</p>
<h2 id="11-用-python-快速开启一个-SMTP-服务"><a href="#11-用-python-快速开启一个-SMTP-服务" class="headerlink" title="11. 用 python 快速开启一个 SMTP 服务"></a>11. 用 python 快速开启一个 SMTP 服务</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>python -m smtpd -n -c DebuggingServer localhost:1025</code></th>
</tr>
</thead>
</table>
<p>这是一个用 Python 标准库 smtpd （用 -m smtpd 指定) 实现在简易 SMTP 服务，运行于 1025 端口 。 另外三个参数的解释： <em>-n</em> <em>参数让</em> <em>Python</em> <em>不要进行</em> <em>setuid (</em> <em>改变用户）为</em> <em>“nobody”</em> <em>，也就是说直接用你的帐号来运行</em> -c DebuggingServer 参数是让 Python 运行时在屏幕上输出调试及运行信息 * localhost:1025 参数则是让 Python 在本地的 1025 端口上开启 SMTP 服务 另外，假如你想让程序运行于标准的 25 的端口上的话，你必须使用 sudo 命令，因为只有 root 才能在 1-1024 端口上开启服务。如下：</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**sudo** python -m smtpd -n -c DebuggingServer localhost:25</code></th>
</tr>
</thead>
</table>
<p>1.查看ascii码表</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>man</strong> 7 ascii</th>
</tr>
</thead>
</table>
<p>很多人初学编程都会接触到ascii码的概念，有时候为了查某个符号的ascii值，可能还得翻箱倒柜找出当年的课本？<a href="http://www.kernel.org/doc/man-pages/" target="_blank" rel="noopener">Linux Manpage</a>里面其实包含了很多类似的实用资料，上述命令就能很详细的方式解释ascii编码，<a href="http://www.kernel.org/doc/man-pages/online/pages/man7/ascii.7.html" target="_blank" rel="noopener">当然这里还有在线版</a>。</p>
<p>man命令的第二个参数是区域码，用来区分索引词的范围，比如printf，在C标准库里面的printf跟bash当中的printf是不同的，前者的查询是man 3 printf，后者是man 1 printf。如果这个区域码省略，就会从1开始搜索，直到找到为止。</p>
<p>命令man man可以<a href="http://www.kernel.org/doc/man-pages/online/pages/man7/man-pages.7.html" target="_blank" rel="noopener">看到详细的解释</a>。</p>
<p>manpages里面还有一些有趣而且实用的资料，可能鲜为人知：</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man1/intro.1.html" target="_blank" rel="noopener">man 1 intro </a>– 一篇对从未接触过Linux的用户的简明教程。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/syscalls.2.html" target="_blank" rel="noopener">man 2 syscalls </a>– 内核系统请求的列表，按内核版本注释分类，系统编程必备。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select_tut.2.html" target="_blank" rel="noopener">man 2 select_tut </a>– 关于select()系统请求的教程。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/string.3.html" target="_blank" rel="noopener">man 3 string </a>– 在头文件内的所有函数。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/stdio.3.html" target="_blank" rel="noopener">man 3 stdio </a>– 关于头文件的使用，标准输入&#x2F;输出库的说明。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/errno.3.html" target="_blank" rel="noopener">man 3 errno </a>– 所有errorno的取值及说明。（C语言内类似其他语言的异常告知机制）</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man4/console_codes.4.html" target="_blank" rel="noopener">man 4 console_codes </a>– Linux的终端控制码及其使用解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man4/full.4.html" target="_blank" rel="noopener">man 4 full </a>– 介绍&#x2F;dev&#x2F;full这个总是处于“满”状态的磁盘。（对应&#x2F;dev&#x2F;null这个总是空的设备）</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html" target="_blank" rel="noopener">man 5 proc </a>– 介绍&#x2F;proc下的文件系统。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man5/filesystems.5.html" target="_blank" rel="noopener">man 5 filesystems </a>– 各种Linux文件系统。</p>
<p>第7区里面的资料通常最酷：</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/bootparam.7.html" target="_blank" rel="noopener">man 7 bootparam </a>– 详细解释内核启动参数。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/charsets.7.html" target="_blank" rel="noopener">man 7 charsets </a>– 解释各种语言的编码集。（gbk，gb2312等）</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/glob.7.html" target="_blank" rel="noopener">man 7 glob </a>– 解释glob文件名管理机制的工作过程。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/hier.7.html" target="_blank" rel="noopener">man 7 hier </a>– 解释Linux文件系统结构各个部分的作用。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/operator.7.html" target="_blank" rel="noopener">man 7 operator </a>– C语言的运算符的列表。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/regex.7.html" target="_blank" rel="noopener">man 7 regex </a>– 介绍正则表达式。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/suffixes.7.html" target="_blank" rel="noopener">man 7 suffixes </a>– 常见文件后缀名的列表跟解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/time.7.html" target="_blank" rel="noopener">man 7 time </a>– Linux的时钟机制解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/units.7.html" target="_blank" rel="noopener">man 7 units </a>– 数值单位及其数值的解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/utf8.7.html" target="_blank" rel="noopener">man 7 utf8 </a>– 描述UTF-8编码。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/url.7.html" target="_blank" rel="noopener">man 7 url </a>– 解释URL、URI、URN等的标准。</p>
<p>2.简易计时器</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>time</strong> <strong>read</strong></th>
</tr>
</thead>
</table>
<p>运行命令开始算起，到结束时按一下Enter，就显示出整个过程的时间，精确到ms级别。</p>
<p>time是用来计算一个进程在运行到结束过程耗费多少时间的程序，它的输出通常有三项：</p>
<table>
<thead>
<tr>
<th>1  2  3  4  5</th>
<th>$ time ls &#x2F;opt  …  real    0m0.008s  user    0m0.003s  sys    0m0.007s</th>
</tr>
</thead>
</table>
<p>real指整个程序对真实世界而言运行所需时间，user指程序在用户空间运行的时间，sys指程序对系统调用锁占用时间。</p>
<p>read本来是一个读取用户输入的命令，常见用法是read LINE，用户输入并回车后，键入的内容就被保存到$LINE变量内，但在键入回车前，这个命令是一直阻塞的。</p>
<p>可见time read这命令灵活地利用了操作系统的阻塞。用这个命令来测试一壶水多久煮滚应该是不错的。</p>
<p>3.远程关掉一台Windows机器</p>
<table>
<thead>
<tr>
<th>1</th>
<th>net rpc shutdown -I  IP_ADDRESS -U username**%**password</th>
</tr>
</thead>
</table>
<p>Windows平台上的net命令是比较强大的，因为其后台是一个RPC类的系统服务，大家应该看过win下用net use \ip\ipc$ *这样一个命令建立IPC空连接，入侵主机的事情。</p>
<p>Linux下的net命令是samba组件的程序，通常包含在smbclient内，可以跟windows主机的文件、打印机共享等服务进行通讯，但是也支持rpc命令。</p>
<p>上述命令就是在远程Windows主机上执行了shutdown命令。当然这不一定成功，关系到win主机上面的安全设置。net命令能够控制到win主机就是了。</p>
<h2 id="4-在一个子shell中运行一个命令"><a href="#4-在一个子shell中运行一个命令" class="headerlink" title="4.在一个子shell中运行一个命令"></a>4.在一个子shell中运行一个命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>(cd</strong> **&#x2F;**tmp <strong>&amp;&amp;</strong> <strong>ls)</strong></th>
</tr>
</thead>
</table>
<p>当然这只是演示，要查看目录当然可以ls &#x2F;tmp。</p>
<p>好处就是不会改变当前shell的目录，以及如果命令中设计环境变量，也不会对当前shell有任何修改。</p>
<p>在Shell编程中还有很多使用上引号来括住一个命令：<code>ls /tmp</code>，这也是子shell过程。可是上引号的方法无法嵌套，而使用小括号的方法可以，一个比较纠结的例子是：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>echo</strong> $<strong>(echo</strong> -e \x$<strong>(printf</strong>  “%x” 65**))**</th>
</tr>
</thead>
</table>
<p>5.利用中间管道嵌套使用SSH</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -t host_A <strong>ssh</strong> host_B</th>
</tr>
</thead>
</table>
<p>如果目标机器host_B处于比较复杂的网络环境，本机无法直接访问，但另外一台host_A能够访问到host_B，而且也能被本机访问到，那上述命令就解决了方便登录host_B的问题。</p>
<p>但理论上这个过程是可以无限嵌套的，比如：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -t host1 <strong>ssh</strong> -t  host2 <strong>ssh</strong> -t  host3 <strong>ssh</strong> -t  host4 …</th>
</tr>
</thead>
</table>
<p>嗯那神马FBI CIA的，有本事来捉我吧～</p>
<p>6.清空屏幕</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>&lt;**CTRL+l**&gt;</strong>;</th>
</tr>
</thead>
</table>
<p>这个跟之前介绍的reset命令重置终端的作用有些类似，其实都只是发送一段控制序列，让终端的显示复位。</p>
<p>还可以这样运行：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>tput <strong>clear</strong></th>
</tr>
</thead>
</table>
<p>tput是专门用来控制终端的一个小工具，也挺强大的，详细信息运行man tput查看。</p>
<h2 id="7-我想知道一台服务器什么时候重启完"><a href="#7-我想知道一台服务器什么时候重启完" class="headerlink" title="7.我想知道一台服务器什么时候重启完"></a>7.我想知道一台服务器什么时候重启完</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ping</strong> -a IP</th>
</tr>
</thead>
</table>
<p>系统管理员最常做的事情是重启系统。但是服务器的重启过程往往得花上好几分钟，什么你的服务器4个scsi卡？16个硬盘？系统是Redhat？还完全安装所有组件？好吧，它重启的时间都够你吃顿饭了，所以我很想知道它什么时候回来。</p>
<p>ping命令有个audible ping参数，-a，当它终于ping通你的服务器时会让小喇叭叫起来。</p>
<h2 id="8-列出你最常用的10条命令"><a href="#8-列出你最常用的10条命令" class="headerlink" title="8.列出你最常用的10条命令"></a>8.列出你最常用的10条命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>history</strong> <strong>|</strong> <strong>awk</strong> ‘{a[$2]++}END{for(i  in a){print a[i] “ “ i}}’ <strong>|</strong>  <strong>sort</strong> -rn  <strong>|</strong> <strong>head</strong></th>
</tr>
</thead>
</table>
<p>这行命令组合得很妙：</p>
<p>history输出用户了命令历史；awk统计并输出列表；sort排序；head截出前10行。</p>
<h2 id="9-检查Gmail新邮件"><a href="#9-检查Gmail新邮件" class="headerlink" title="9.检查Gmail新邮件"></a>9.检查Gmail新邮件</h2><table>
<thead>
<tr>
<th>1  2  3  4  5  6</th>
<th>curl -u you**@**gmail.com –silent  “<a href="https://mail.google.com/mail/feed/atom" target="_blank" rel="noopener">https://mail.google.com/mail/feed/atom</a>“  <strong>|</strong>   <strong>perl</strong> -ne  \   ‘      print “Subject: $1 “ if &#x2F;<title>(.+?)&lt;/title&gt;&#x2F;  &amp;&amp; $title++;      print “(from $1)\n” if &#x2F;<email>(.+?)&lt;/email&gt;&#x2F;;   ‘</email></title></th>
</tr>
</thead>
</table>
<p>Gmail的一个特色是支持Atom feed输出邮件列表，所以总是见到很多Gmail邮件提醒器之类的，因为开发特简单，atom很方便。</p>
<p>这里只是利用了perl的正则来解析atom（sed&#x2F;awk也能做到）。</p>
<h2 id="10-用Telnet看《星球大战》"><a href="#10-用Telnet看《星球大战》" class="headerlink" title="10.用Telnet看《星球大战》"></a>10.用Telnet看《星球大战》</h2><table>
<thead>
<tr>
<th>1</th>
<th>telnet towel.blinkenlights.nl</th>
</tr>
</thead>
</table>
<p>没什么好解释的，就是ASCII艺术之一。如果你有ipv6连接，还能看到彩色版的。牛吧？</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/shell/" rel="tag"># shell</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/12/ss用法大全/" rel="next" title="就是要你懂网络监控--ss用法大全">
                <i class="fa fa-chevron-left"></i> 就是要你懂网络监控--ss用法大全
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/14/通过分析tcp包来确认服务调用的响应时间/" rel="prev" title="通过分析tcp包来确认服务调用的响应时间">
                通过分析tcp包来确认服务调用的响应时间 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="twitter @plantegg">
          <p class="site-author-name" itemprop="name">twitter @plantegg</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">191</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">282</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#最牛B的Linux-Shell命令"><span class="nav-number">1.</span> <span class="nav-text">最牛B的Linux Shell命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-以sudo运行上条命令"><span class="nav-number">1.2.</span> <span class="nav-text">1.以sudo运行上条命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-以HTTP方式共享当前文件夹的文件"><span class="nav-number">1.3.</span> <span class="nav-text">2.以HTTP方式共享当前文件夹的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find"><span class="nav-number">1.4.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#top"><span class="nav-number">1.5.</span> <span class="nav-text">top</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs-传参数"><span class="nav-number">1.6.</span> <span class="nav-text">xargs 传参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非贪婪匹配"><span class="nav-number">1.7.</span> <span class="nav-text">非贪婪匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#macOS-sed-删除行"><span class="nav-number">1.8.</span> <span class="nav-text">macOS sed 删除行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ps-查看进程"><span class="nav-number">1.9.</span> <span class="nav-text">ps 查看进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环按行处理"><span class="nav-number">1.10.</span> <span class="nav-text">循环按行处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-在以普通用户打开的vim当中保存一个root用户文件"><span class="nav-number">1.11.</span> <span class="nav-text">3.在以普通用户打开的vim当中保存一个root用户文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-切换回上一个目录"><span class="nav-number">1.12.</span> <span class="nav-text">4.切换回上一个目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-替换上一条命令中的一个短语"><span class="nav-number">1.13.</span> <span class="nav-text">5.替换上一条命令中的一个短语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-快速备份一个文件"><span class="nav-number">1.14.</span> <span class="nav-text">6.快速备份一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-免密码ssh登录主机"><span class="nav-number">1.15.</span> <span class="nav-text">7.免密码ssh登录主机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-抓取Linux桌面的视频"><span class="nav-number">1.16.</span> <span class="nav-text">8.抓取Linux桌面的视频</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-用你最喜欢的编辑器来敲命令"><span class="nav-number">1.17.</span> <span class="nav-text">1.用你最喜欢的编辑器来敲命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-清空或创建一个文件"><span class="nav-number">1.18.</span> <span class="nav-text">2.清空或创建一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-用ssh创建端口转发通道"><span class="nav-number">1.19.</span> <span class="nav-text">3.用ssh创建端口转发通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-重置终端"><span class="nav-number">1.20.</span> <span class="nav-text">4.重置终端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-在午夜的时候执行某命令"><span class="nav-number">1.21.</span> <span class="nav-text">5.在午夜的时候执行某命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-远程传送麦克风语音"><span class="nav-number">1.22.</span> <span class="nav-text">6.远程传送麦克风语音</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-映射一个内存目录"><span class="nav-number">1.23.</span> <span class="nav-text">7.映射一个内存目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-用diff对比远程文件跟本地文件"><span class="nav-number">1.24.</span> <span class="nav-text">8.用diff对比远程文件跟本地文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-查看系统中占用端口的进程"><span class="nav-number">1.25.</span> <span class="nav-text">9.查看系统中占用端口的进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-更友好的显示当前挂载的文件系统"><span class="nav-number">1.26.</span> <span class="nav-text">1. 更友好的显示当前挂载的文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”"><span class="nav-number">1.27.</span> <span class="nav-text">2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-实时某个目录下查看最新改动过的文件"><span class="nav-number">1.28.</span> <span class="nav-text">3. 实时某个目录下查看最新改动过的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-通过-SSH-挂载远程主机上的文件夹"><span class="nav-number">1.29.</span> <span class="nav-text">4. 通过 SSH 挂载远程主机上的文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-通过-DNS-来读取-Wikipedia-的词条"><span class="nav-number">1.30.</span> <span class="nav-text">5. 通过 DNS 来读取 Wikipedia 的词条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-用-Wget-的递归方式下载整个网站"><span class="nav-number">1.31.</span> <span class="nav-text">6. 用 Wget 的递归方式下载整个网站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-复制最后使用的命令中的参数"><span class="nav-number">1.32.</span> <span class="nav-text">7. 复制最后使用的命令中的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-执行一条命令但不保存到-history-中"><span class="nav-number">1.33.</span> <span class="nav-text">8. 执行一条命令但不保存到 history 中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-显示当前目录中所有子目录的大小-du"><span class="nav-number">1.34.</span> <span class="nav-text">9. 显示当前目录中所有子目录的大小 du</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序"><span class="nav-number">1.35.</span> <span class="nav-text">10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-用-python-快速开启一个-SMTP-服务"><span class="nav-number">1.36.</span> <span class="nav-text">11. 用 python 快速开启一个 SMTP 服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-在一个子shell中运行一个命令"><span class="nav-number">1.37.</span> <span class="nav-text">4.在一个子shell中运行一个命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-我想知道一台服务器什么时候重启完"><span class="nav-number">1.38.</span> <span class="nav-text">7.我想知道一台服务器什么时候重启完</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-列出你最常用的10条命令"><span class="nav-number">1.39.</span> <span class="nav-text">8.列出你最常用的10条命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-检查Gmail新邮件"><span class="nav-number">1.40.</span> <span class="nav-text">9.检查Gmail新邮件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-用Telnet看《星球大战》"><span class="nav-number">1.41.</span> <span class="nav-text">10.用Telnet看《星球大战》</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">twitter @plantegg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv_footer"></span>次
</span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv_footer"></span>人次
</span>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
