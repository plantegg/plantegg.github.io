<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"plantegg.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="最牛B的Linux Shell命令引言Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。 本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑">
<meta property="og:type" content="article">
<meta property="og:title" content="最牛B的Linux Shell命令">
<meta property="og:url" content="https://plantegg.github.io/2017/01/01/top_linux_commands/index.html">
<meta property="og:site_name" content="plantegg">
<meta property="og:description" content="最牛B的Linux Shell命令引言Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。 本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-01-01T09:30:03.000Z">
<meta property="article:modified_time" content="2025-11-16T11:58:49.544Z">
<meta property="article:author" content="twitter @plantegg">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://plantegg.github.io/2017/01/01/top_linux_commands/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://plantegg.github.io/2017/01/01/top_linux_commands/","path":"2017/01/01/top_linux_commands/","title":"最牛B的Linux Shell命令"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>最牛B的Linux Shell命令 | plantegg</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">plantegg</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">java tcp mysql performance network docker Linux</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E7%89%9BB%E7%9A%84Linux-Shell%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">最牛B的Linux Shell命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%A5sudo%E8%BF%90%E8%A1%8C%E4%B8%8A%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.</span> <span class="nav-text">1.以sudo运行上条命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%A5HTTP%E6%96%B9%E5%BC%8F%E5%85%B1%E4%BA%AB%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">2.以HTTP方式共享当前文件夹的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find"><span class="nav-number">1.4.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#top"><span class="nav-number">1.5.</span> <span class="nav-text">top</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs-%E4%BC%A0%E5%8F%82%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">xargs 传参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D"><span class="nav-number">1.7.</span> <span class="nav-text">非贪婪匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#macOS-sed-%E5%88%A0%E9%99%A4%E8%A1%8C"><span class="nav-number">1.8.</span> <span class="nav-text">macOS sed 删除行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ps-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.9.</span> <span class="nav-text">ps 查看进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%8C%89%E8%A1%8C%E5%A4%84%E7%90%86"><span class="nav-number">1.10.</span> <span class="nav-text">循环按行处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%9C%A8%E4%BB%A5%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E7%9A%84vim%E5%BD%93%E4%B8%AD%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AAroot%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6"><span class="nav-number">1.11.</span> <span class="nav-text">3.在以普通用户打开的vim当中保存一个root用户文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%88%87%E6%8D%A2%E5%9B%9E%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95"><span class="nav-number">1.12.</span> <span class="nav-text">4.切换回上一个目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%9B%BF%E6%8D%A2%E4%B8%8A%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%9F%AD%E8%AF%AD"><span class="nav-number">1.13.</span> <span class="nav-text">5.替换上一条命令中的一个短语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%BF%AB%E9%80%9F%E5%A4%87%E4%BB%BD%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">1.14.</span> <span class="nav-text">6.快速备份一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%85%8D%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95%E4%B8%BB%E6%9C%BA"><span class="nav-number">1.15.</span> <span class="nav-text">7.免密码ssh登录主机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%8A%93%E5%8F%96Linux%E6%A1%8C%E9%9D%A2%E7%9A%84%E8%A7%86%E9%A2%91"><span class="nav-number">1.16.</span> <span class="nav-text">8.抓取Linux桌面的视频</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%94%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%9D%A5%E6%95%B2%E5%91%BD%E4%BB%A4"><span class="nav-number">1.17.</span> <span class="nav-text">1.用你最喜欢的编辑器来敲命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">1.18.</span> <span class="nav-text">2.清空或创建一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%94%A8ssh%E5%88%9B%E5%BB%BA%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%80%9A%E9%81%93"><span class="nav-number">1.19.</span> <span class="nav-text">3.用ssh创建端口转发通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%87%8D%E7%BD%AE%E7%BB%88%E7%AB%AF"><span class="nav-number">1.20.</span> <span class="nav-text">4.重置终端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%9C%A8%E5%8D%88%E5%A4%9C%E7%9A%84%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E6%9F%90%E5%91%BD%E4%BB%A4"><span class="nav-number">1.21.</span> <span class="nav-text">5.在午夜的时候执行某命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%BF%9C%E7%A8%8B%E4%BC%A0%E9%80%81%E9%BA%A6%E5%85%8B%E9%A3%8E%E8%AF%AD%E9%9F%B3"><span class="nav-number">1.22.</span> <span class="nav-text">6.远程传送麦克风语音</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%98%A0%E5%B0%84%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E7%9B%AE%E5%BD%95"><span class="nav-number">1.23.</span> <span class="nav-text">7.映射一个内存目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%94%A8diff%E5%AF%B9%E6%AF%94%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E8%B7%9F%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="nav-number">1.24.</span> <span class="nav-text">8.用diff对比远程文件跟本地文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.25.</span> <span class="nav-text">9.查看系统中占用端口的进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%9B%B4%E5%8F%8B%E5%A5%BD%E7%9A%84%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%8C%82%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.26.</span> <span class="nav-text">1. 更友好的显示当前挂载的文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%90%E8%A1%8C%E5%89%8D%E4%B8%80%E4%B8%AA-Shell-%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%90%8C%E6%97%B6%E7%94%A8-%E2%80%9Cbar%E2%80%9D-%E6%9B%BF%E6%8D%A2%E6%8E%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA-%E2%80%9Cfoo%E2%80%9D"><span class="nav-number">1.27.</span> <span class="nav-text">2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%9E%E6%97%B6%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%9C%80%E6%96%B0%E6%94%B9%E5%8A%A8%E8%BF%87%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">1.28.</span> <span class="nav-text">3. 实时某个目录下查看最新改动过的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%80%9A%E8%BF%87-SSH-%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">1.29.</span> <span class="nav-text">4. 通过 SSH 挂载远程主机上的文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%80%9A%E8%BF%87-DNS-%E6%9D%A5%E8%AF%BB%E5%8F%96-Wikipedia-%E7%9A%84%E8%AF%8D%E6%9D%A1"><span class="nav-number">1.30.</span> <span class="nav-text">5. 通过 DNS 来读取 Wikipedia 的词条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%94%A8-Wget-%E7%9A%84%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%E6%95%B4%E4%B8%AA%E7%BD%91%E7%AB%99"><span class="nav-number">1.31.</span> <span class="nav-text">6. 用 Wget 的递归方式下载整个网站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%A4%8D%E5%88%B6%E6%9C%80%E5%90%8E%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.32.</span> <span class="nav-text">7. 复制最后使用的命令中的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E4%BD%86%E4%B8%8D%E4%BF%9D%E5%AD%98%E5%88%B0-history-%E4%B8%AD"><span class="nav-number">1.33.</span> <span class="nav-text">8. 执行一条命令但不保存到 history 中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%90%E7%9B%AE%E5%BD%95%E7%9A%84%E5%A4%A7%E5%B0%8F-du"><span class="nav-number">1.34.</span> <span class="nav-text">9. 显示当前目录中所有子目录的大小 du</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%98%BE%E7%A4%BA%E6%B6%88%E8%80%97%E5%86%85%E5%AD%98%E6%9C%80%E5%A4%9A%E7%9A%84-10-%E4%B8%AA%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%BB%A5%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.35.</span> <span class="nav-text">10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%94%A8-python-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA-SMTP-%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.36.</span> <span class="nav-text">11. 用 python 快速开启一个 SMTP 服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%90shell%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="nav-number">1.37.</span> <span class="nav-text">4.在一个子shell中运行一个命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8D%E5%90%AF%E5%AE%8C"><span class="nav-number">1.38.</span> <span class="nav-text">7.我想知道一台服务器什么时候重启完</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%88%97%E5%87%BA%E4%BD%A0%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8410%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">1.39.</span> <span class="nav-text">8.列出你最常用的10条命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%A3%80%E6%9F%A5Gmail%E6%96%B0%E9%82%AE%E4%BB%B6"><span class="nav-number">1.40.</span> <span class="nav-text">9.检查Gmail新邮件</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">twitter @plantegg</p>
  <div class="site-description" itemprop="description">java mysql tcp performance network docker Linux</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">282</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/01/01/top_linux_commands/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twitter @plantegg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
      <meta itemprop="description" content="java mysql tcp performance network docker Linux">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="最牛B的Linux Shell命令 | plantegg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          最牛B的Linux Shell命令
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-01 17:30:03" itemprop="dateCreated datePublished" datetime="2017-01-01T17:30:03+08:00">2017-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-16 19:58:49" itemprop="dateModified" datetime="2025-11-16T19:58:49+08:00">2025-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="最牛B的Linux-Shell命令"><a href="#最牛B的Linux-Shell命令" class="headerlink" title="最牛B的Linux Shell命令"></a>最牛B的Linux Shell命令</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。</p>
<p>本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑了。</p>
<h2 id="1-以sudo运行上条命令"><a href="#1-以sudo运行上条命令" class="headerlink" title="1.以sudo运行上条命令"></a>1.以sudo运行上条命令</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>sudo</strong> <strong>!!</strong></th>
</tr>
</thead>
</table>
<p>大家应该都知sudo，不解释。但通常出现的情况是，敲完命令执行后报错才发现忘了sudo。这时候，新手用户就会：按上箭头，按左箭头，盯着光标回到开始处，输入sudo，回车；高手用户就蛋定多了，按Ctrl-p，按Ctrl-a，输入sudo，回车。</p>
<p>这里介绍这个是天外飞仙级别的，对，就直接sudo !!。</p>
<p>当然这几种解决方式效果是完全一样的，只是款不一样，嗯，不解释。</p>
<p>两个感叹号其实是bash的一个特性，称为事件引用符（event designators）。!!其实相当于!-1，引用前一条命令，当然也可以!-2，!-50。默认情况下bash会在~&#x2F;.bash_history文件内记录用户执行的最近500条命令，history命令可以显示这些命令。</p>
<p>关于事件引用符的更多用法可以深入阅读<a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/">The Definitive Guide to Bash Command Line History</a>。</p>
<h2 id="2-以HTTP方式共享当前文件夹的文件"><a href="#2-以HTTP方式共享当前文件夹的文件" class="headerlink" title="2.以HTTP方式共享当前文件夹的文件"></a>2.以HTTP方式共享当前文件夹的文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ python -m  SimpleHTTPServer 8080</th>
</tr>
</thead>
</table>
<p>这命令启动了Python的SimpleHTTPServer模块，考虑到Python在绝大多数的Linux发行版当中都默认安装，所以这个命令很可能是最简单的跨平台传文件的方法。</p>
<p>命令执行后将在本机8000端口开放HTTP服务，在其他能访问本机的机器的浏览器打开ttp:&#x2F;&#x2F;ip:8000即打开一个目录列表，点击即可下载。</p>
<p>python3的话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#最近一天修改的md文档</span><br><span class="line">find . -maxdepth 1 -type f -mtime -1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec ls -lh &quot;&#123;&#125;&quot; \;</span><br><span class="line"></span><br><span class="line">find . -size 0  -type f -exec ls -lh &quot;&#123;&#125;&quot; \;</span><br><span class="line"></span><br><span class="line">find . -maxdepth 1 -type f -mtime -2 -name &quot;*margin*&quot; -exec mv &quot;&#123;&#125;&quot; /tmp/img/ \;</span><br><span class="line"></span><br><span class="line">#clean the big file, but exclude spill dir</span><br><span class="line">sudo find /home/admin/ -not -path &quot;*/spill/*&quot; -type f -size +3G -exec cp /dev/null &#123;&#125; \;</span><br><span class="line">sudo find /home/admin/ -type f -name &quot;*.hprof&quot; -mtime +1 -exec rm -f &#123;&#125; \;</span><br><span class="line">#clean the spill temp file which before 7 days ago</span><br><span class="line">sudo find /home/admin/ -type f -mtime +7 -exec cp /dev/null &#123;&#125; \;</span><br><span class="line">sudo find /home/admin/logs/ -type f -mtime +7 -exec rm -f &#123;&#125; \;</span><br><span class="line">sudo find /var/log/ -type f -size +500M -exec cp /dev/null &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">// -mindepth 1 可以忽略当前目录的&quot;.&quot; </span><br><span class="line">find . -mindepth 1 -maxdepth 1 -type d -mtime -50</span><br><span class="line"></span><br><span class="line">#备份匹配的文件</span><br><span class="line">find . -name &#x27;*.ibd&#x27; | grep tpcc1000 | grep -v mysql_global | xargs -I&#123;&#125; cp --path &#123;&#125; /tmp/bak/</span><br><span class="line"></span><br><span class="line">#将yaml 备份，保留目录结构</span><br><span class="line">find . -name &#x27;*.yaml&#x27; | xargs -I&#123;&#125; cp --path &#123;&#125; /tmp/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find $srcDir -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec ls -lh &quot;&#123;&#125;&quot; \;</span><br><span class="line"></span><br><span class="line">find $srcDir -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec cp &quot;&#123;&#125;&quot; ./source/_posts/ \;</span><br><span class="line"></span><br><span class="line">#sudo find /media/sf_D_DRIVE/case/ -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -print -exec cp &quot;&#123;&#125;&quot; ./source/_posts/ \;</span><br><span class="line"></span><br><span class="line">cat的时候输出文件名：</span><br><span class="line">find . -type f -print -exec cat &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>xargs 参数：</p>
<blockquote>
<p>-I [replace-str]：将xargs的输出每一项参数，单独赋值给后面的命令，参数需要用指定的代替字符串replace-str代替，也就是说replace-str不可缺省，必须显示指明，可以使用{} $ @等符号，其主要作用是<strong>当xargs command后有多个参数时，调整参数位置</strong></p>
</blockquote>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>默认配置文件：<del>&#x2F;.toprc （on Ubuntu, it is *</del>&#x2F;.config&#x2F;procps&#x2F;toprc*）</p>
<p>增加列：f (此时可以调整用 → 选择列并调整位置， 此时也有4个窗口可以选择)</p>
<p>按node展示cpu：2(3 选择需要展示的node)</p>
<p>按core展示cpu: 1</p>
<p>切换颜色：z (有4个窗口可以选择，按 g 可以选择1-4)</p>
<p>配置颜色: Z </p>
<p><strong>V</strong> 切换成森林视图，也就是展示进程父子关系</p>
<p>保存配置: W</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dG9wJ3MgQ29uZmlnIEZpbGUgKExpbnV4IHByb2Nlc3NlcyB3aXRoIHdpbmRvd3MpCklkOmksIE1vZGVfYWx0c2NyPTAsIE1vZGVfaXJpeHBzPTEsIERlbGF5X3RpbWU9My4wLCBDdXJ3aW49MApDcHUJZmllbGRzY3VyPaWmqLWztLu9wMS3urg5xScpKissLS4vMDEyNjw+P0FCQ0ZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWoKCXdpbmZsYWdzPTE5NTM4MCwgc29ydGluZHg9MTgsIG1heHRhc2tzPTAsIGdyYXBoX2NwdXM9MCwgZ3JhcGhfbWVtcz0wCglzdW1tY2xyPTQsIG1zZ3NjbHI9MSwgaGVhZGNscj0zLCB0YXNrY2xyPTQKTWVtCWZpZWxkc2N1cj2lu73AvMPBws3OJjk3uigzNEQnxSkqKywtLi8wMTI1Njg+P0ZHSElKS0xPUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqCgl3aW5mbGFncz0xOTUzODAsIHNvcnRpbmR4PTIxLCBtYXh0YXNrcz0wLCBncmFwaF9jcHVzPTAsIGdyYXBoX21lbXM9MAoJc3VtbWNscj02LCBtc2dzY2xyPTYsIGhlYWRjbHI9MywgdGFza2Nscj02ClNjaAlmaWVsZHNjdXI9pTo7PD0+P0BBTUJOQ7WztMfEtre5xcYmJygpKissLS4vMDEyOEhJSktMT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpagoJd2luZmxhZ3M9MTk0ODY4LCBzb3J0aW5keD0wLCBtYXh0YXNrcz0wLCBncmFwaF9jcHVzPTAsIGdyYXBoX21lbXM9MAoJc3VtbWNscj01LCBtc2dzY2xyPTUsIGhlYWRjbHI9MywgdGFza2Nscj01CkNncAlmaWVsZHNjdXI9paanqCowOTc6RCkrLC0uLzEyMzQ1Njg7PD0+P0BBQkNGR8hJSktMTU5P0NHS09TVxVZXWFlaW1xdXl9gYWJjZGVmZ2hpagoJd2luZmxhZ3M9MTk0ODY4LCBzb3J0aW5keD0wLCBtYXh0YXNrcz0wLCBncmFwaF9jcHVzPTAsIGdyYXBoX21lbXM9MAoJc3VtbWNscj0yLCBtc2dzY2xyPTMsIGhlYWRjbHI9MywgdGFza2Nscj0yCkZpeGVkX3dpZGVzdD0wLCBTdW1tX21zY2FsZT0wLCBUYXNrX21zY2FsZT0wLCBaZXJvX3N1cHByZXNzPTAKCnBpcGUJTmV0RmlsZXMJbHNvZiAtYSAtbCAtbiAtUCAtaTQgLXAgJWQgMj4mMQpwaXBlCU9wZW5GaWxlcwlsc29mIC1hIC1sIC1uIC1QIC1wICVkIDI+JjEKZmlsZQlOVU1BSW5mbwkvcHJvYy8lZC9udW1hX21hcHMK</span><br></pre></td></tr></table></figure>



<h2 id="xargs-传参数"><a href="#xargs-传参数" class="headerlink" title="xargs 传参数"></a>xargs 传参数</h2><blockquote>
<p>ls &#x2F;xx | xargs -t -I{}  cp {} &#x2F;tmp&#x2F;{}</p>
</blockquote>
<p>-t ： 打印内容，去掉\n之后的字符串</p>
<p>-I :  后面定义占位符，上例子是{}  ，后面命令行中可以多次使用占位符</p>
<p>挂载多台苹果的例子</p>
<blockquote>
<p> idevice_id -l|xargs -t -I{} mkdir {};idevice_id -l |xargs -t -I{} ifuse {} {}</p>
</blockquote>
<p>批量执行docker exec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible -i host.ini all -m shell -a &quot;docker ps -a | grep tpcc | grep dn | cut -d &#x27; &#x27; -f 1 | xargs  -I&#123;&#125; docker exec &#123;&#125; bash -c \&quot;myc -e &#x27;shutdown&#x27;\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>批量推送镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images |grep &quot;docker.io:5000&quot; | awk &#x27;&#123; print $1&quot;:&quot;$2 &#125;&#x27; | xargs -I &#123;&#125; docker push &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>vim中默认匹配：abc.*d 是贪婪匹配，也就是尽可能长地匹配，改用 abc.{-}d 匹配到第一个 d字符就结束</p>
<blockquote>
<p>贪婪模式是: .*</p>
<p>非贪婪模式是: .\{-}</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\&#123;n,m&#125; Matches n to m of the preceding atom, as many as possible</span><br><span class="line">\&#123;n&#125; Matches n of the preceding atom</span><br><span class="line">\&#123;n,&#125; Matches at least n of the preceding atom, as many as possible</span><br><span class="line">\&#123;,m&#125; Matches 0 to m of the preceding atom, as many as possible</span><br><span class="line">\&#123;&#125; Matches 0 or more of the preceding atom, as many as possible (like *)</span><br><span class="line">*/\&#123;-*</span><br><span class="line">\&#123;-n,m&#125; matches n to m of the preceding atom, as few as possible</span><br><span class="line">\&#123;-n&#125; matches n of the preceding atom</span><br><span class="line">\&#123;-n,&#125; matches at least n of the preceding atom, as few as possible</span><br><span class="line">\&#123;-,m&#125; matches 0 to m of the preceding atom, as few as possible</span><br><span class="line">\&#123;-&#125; matches 0 or more of the preceding atom, as few as possibles</span><br></pre></td></tr></table></figure>

<p>grep 非贪婪匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep --color -P &quot;agHost.*?,&quot; test.table  //匹配 agHost后带有多个任意字符直到第一个 逗号 结束，-P表示用 perl 的匹配语法，而perl默认是不支持贪婪的</span><br><span class="line"></span><br><span class="line">grep --color -o -P &quot;agHost.*?,&quot; test.table  //-o 只打印匹配部分</span><br></pre></td></tr></table></figure>

<p>匹配数字至少4次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -E &quot;,rows=[0-9]&#123;4,&#125;&quot;</span><br><span class="line">grep -E &quot;[0-9]&#123;4,&#125;ms&quot; mongod.log</span><br></pre></td></tr></table></figure>



<h2 id="macOS-sed-删除行"><a href="#macOS-sed-删除行" class="headerlink" title="macOS sed 删除行"></a>macOS sed 删除行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查找匹配的行：|      |                               |</span><br><span class="line">grep -E &quot;\| [[:space:]]*\| [[:space:]]*\|&quot; top_linux_commands.md -B3</span><br><span class="line"></span><br><span class="line">//删除行 -i &quot;.bak&quot;是直接操作文件并添加.bak作为备份文件名称，如果不需要备份文件，则使用-i &quot;&quot;</span><br><span class="line">sed -i &#x27;&#x27; -e  &#x27;/\| [[:space:]]*\| [[:space:]]*\|/d&#x27;  top_linux_commands.md</span><br><span class="line"></span><br><span class="line">//先备份文件为.bak, 再删除行 -i &quot;.bak&quot;是添加.bak作为备份文件名称</span><br><span class="line">sed -i &#x27;.bak&#x27; &#x27;s/\| [[:space:]]*\| [[:space:]]*\|/d&#x27;  top_linux_commands.md</span><br></pre></td></tr></table></figure>

<h2 id="ps-查看进程"><a href="#ps-查看进程" class="headerlink" title="ps 查看进程"></a>ps 查看进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -Tfp pid // -T 展开进程下的线程 -f full -p pid</span><br></pre></td></tr></table></figure>



<h2 id="循环按行处理"><a href="#循环按行处理" class="headerlink" title="循环按行处理"></a>循环按行处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while  read i ; do echo $i ; done &lt;./prometheus.list</span><br></pre></td></tr></table></figure>



<h2 id="3-在以普通用户打开的vim当中保存一个root用户文件"><a href="#3-在以普通用户打开的vim当中保存一个root用户文件" class="headerlink" title="3.在以普通用户打开的vim当中保存一个root用户文件"></a>3.在以普通用户打开的vim当中保存一个root用户文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>:<strong>w</strong> <strong>!sudo</strong> <strong>tee</strong> <strong>%</strong></th>
</tr>
</thead>
</table>
<p>这题目读起来纠结，其实是很常见的，常常忘记了sudo就直接用vim编辑&#x2F;etc内的文件，（不过也不一定，vim发现保存的文件无法保存时候会提示）等编辑好了，保存时候才发现没权限。曲线方法是先保存个临时文件，退出后再sudo cp回去。不过实际上在vim里面可以直接完成这个过程的，命令就是如此。</p>
<p>查阅vim的文档（输入:help :w），会提到命令:w!{cmd}，让vim执行一个外部命令{cmd}，然后把当前缓冲区的内容从stdin传入。</p>
<p>tee是一个把stdin保存到文件的小工具。</p>
<p>而%，是vim当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。</p>
<p>所以执行这个命令，就相当于从vim外部修改了当前编辑的文件，好完工。</p>
<h2 id="4-切换回上一个目录"><a href="#4-切换回上一个目录" class="headerlink" title="4.切换回上一个目录"></a>4.切换回上一个目录</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>cd</strong> -</th>
</tr>
</thead>
</table>
<p>应该不少人都知道这个，横杆-代表上一个目录的路径。</p>
<p>实际上cd -就是cd $OLDPWD的简写，bash的固定变量$OLDPWD总保存着之前一个目录的路径。</p>
<p>相对地，$PWD总保存着当前目录的路径。这些变量在编写shell脚本时候相当有用。</p>
<h2 id="5-替换上一条命令中的一个短语"><a href="#5-替换上一条命令中的一个短语" class="headerlink" title="5.替换上一条命令中的一个短语"></a>5.替换上一条命令中的一个短语</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ ^foo^bar^</th>
</tr>
</thead>
</table>
<p>又是另外一个事件引用符（event designator），可以把上一条命令当中的foo替换成bar。</p>
<p>在需要重复运行调试一道长长的命令，需要测试某个参数时候，用这个命令会比较实用；但多数人会首先选择按上箭头提出上道命令，再移动光标去修改某参数，这样更直观，但效率上就不够使用引用符高，而且在脚本中用这个方法可以简化很多。</p>
<p>这道命令的原始样式应该是这样的:</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>!!</strong>:s**&#x2F;<strong>foo</strong>&#x2F;<strong>bar</strong>&#x2F;**</th>
</tr>
</thead>
</table>
<p>本文一开始介绍过!!，后面的一段大家应该很熟悉，vim、sed的替换操作都是这样的语法。</p>
<p>关于事件引用符的更多用法可以深入阅读<a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/">The Definitive Guide to Bash Command Line History</a></p>
<h2 id="6-快速备份一个文件"><a href="#6-快速备份一个文件" class="headerlink" title="6.快速备份一个文件"></a>6.快速备份一个文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>cp</strong>  filename**{<strong>,.bak</strong>}**</th>
</tr>
</thead>
</table>
<p>这道命令把filename文件拷贝成filename.bak，大家应该在一些比较复杂的安装教程里面见过这样的用法。其原理就在于bash对大括号的展开操作，filename{,.bak}这一段会被展开成filename filename.bak再传给cp，于是就有了备份的命令了。</p>
<p>大括号在bash里面是一个排列的意义，可以试试这个：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>echo</strong> <strong>{<strong>a,b,c</strong>}{<strong>a,b,c</strong>}{<strong>a,b,c</strong>}</strong></th>
</tr>
</thead>
</table>
<p>将输出三个集合的全排列:</p>
<p>aaa aab aac aba abb abc aca acb acc</p>
<p>baa bab bac bba bbb bbc bca bcb bcc</p>
<p>caa cab cac cba cbb cbc cca ccb ccc</p>
<p>关于shell当中的集合操作，可深入阅读<a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/set-operations-in-unix-shell/">“Set Operations in the Unix Shell”</a></p>
<h2 id="7-免密码ssh登录主机"><a href="#7-免密码ssh登录主机" class="headerlink" title="7.免密码ssh登录主机"></a>7.免密码ssh登录主机</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ ssh-copy-id remote-machine</th>
</tr>
</thead>
</table>
<p>这个命令把当前用户的公钥串写入到远程主机的~&#x2F;.ssh&#x2F;authorized_keys内，这样下次使用ssh登录的时候，远程主机就直接根据这串密钥完成身份校验，不再询问密码了。前提是你当前用户有生成了公钥，默认是没有的，先执行ssh-keygen试试吧！</p>
<p>这个命令如果用手工完成，是这样的：</p>
<table>
<thead>
<tr>
<th>1  2  3</th>
<th>your-machine$ scp  ~&#x2F;.ssh&#x2F;identity.pub  remote-machine:  your-machine$ ssh  remote-machine  remote-machine$ cat  identity.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</th>
</tr>
</thead>
</table>
<p>如果你想删掉远程主机上的密钥，直接打开authorized_keys，搜索你的用户名，删除那行，即可。</p>
<h2 id="8-抓取Linux桌面的视频"><a href="#8-抓取Linux桌面的视频" class="headerlink" title="8.抓取Linux桌面的视频"></a>8.抓取Linux桌面的视频</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>ffmpeg</strong> -f x11grab -s  wxga -r 25  -i :0.0 -sameq **&#x2F;<strong>tmp</strong>&#x2F;**out.mpg</th>
</tr>
</thead>
</table>
<p>我们在一些视频网站上看到别人的3D桌面怎么怎么酷的视频，通常就是这么来的，ffmpeg可以直接解码X11的图形，并转换到相应输出格式。</p>
<p>ffmpeg的通常用法是，根据一堆参数，输出一个文件，输出文件通常放最后，下面解析下几个参数：</p>
<p>-f x11grab 指定输入类型。因为x11的缓冲区不是普通的视频文件可以侦测格式，必须指定后ffmpeg才知道如何获得输入。</p>
<p>-s wxga 设置抓取区域的大小。wxga是1366*768的标准说法，也可以换成-s 800×600的写法。</p>
<p>-r 25 设置帧率，即每秒抓取的画面数。</p>
<p>-i :0.0 设置输入源，本地X默认在0.0</p>
<p>-sameq 保持跟输入流一样的图像质量，以用来后期处理。</p>
<p>至于其他ffmpeg的用法，可以参考下面两篇文章：</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/how-to-extract-audio-tracks-from-youtube-videos/">How to Extract Audio Tracks from YouTube Videos</a></p>
<p>·    <a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/converting-youtube-flvs-to-a-better-format-with-ffmpeg">Converting YouTube Flash Videos to a Better Format with ffmpeg</a></p>
<p>后记</p>
<p>说Shell是一种编程语言，可能有些尴尬，虽然很多人每天都在用Shell，但从来没见它荣登TIOBE编程语言排行榜之类的，可以说毫无名分，因为很多用户没意识到它是一种语言，只当做这是一个能够很好完成任务的工具，基本得理所当然，就好像GUI程序的菜单、按钮一样。</p>
<p>掌握Shell，通常能够让任务在数秒钟内完成，这就让Shell跟C、Perl、Python这些语言区别开来，没人否认后者更能胜任更多的任务，但是他们是在不同的层面上去做，Shell依赖大量的系统组件黏合调用，而后者依赖各种库，各所擅长不同的应用领域，比喻就是，Shell是混凝土，可以很方便地粘合一些建筑组件而成为稳固的高楼大厦；但同样是粘合剂，粘玻璃窗、粘书报、粘皮鞋，混凝土是绝对不合适的，Shell并不擅长一些细致操作，比如它连浮点运算都不支持，更别提什么图形运算什么的。但这并不妨碍Shell来帮我们完成很多粗重任务。</p>
<p>Shell的工作方式，大多数入门用户会觉得枯燥难学，而所谓的经典教材也离不开《Advanced Bash-Scripting》、《Bash Guide for Beginners》，但类似本文这样的一些“雕虫小技”因为难登大雅之堂绝不会收录进去。这情况如果象国外一些unix用户比较多的地方会有很好改善，即使是新手，偶尔看看别人的操作都能“偷师”一手，我编译本系列文章其实也就希望稍微改善一下这个状况。</p>
<h2 id="1-用你最喜欢的编辑器来敲命令"><a href="#1-用你最喜欢的编辑器来敲命令" class="headerlink" title="1.用你最喜欢的编辑器来敲命令"></a>1.用你最喜欢的编辑器来敲命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>command</strong> <strong>&lt;**CTRL-x  CTRL-e**&gt;</strong></th>
</tr>
</thead>
</table>
<p>在已经敲完的命令后按<CTRL-x CTRL-e>，会打开一个你指定的编辑器（比如vim，通过环境变量$EDITOR指定），里面就是你刚输入的命令，然后爱怎么编辑就怎么编辑吧，特别是那些参数异常复杂的程序，比如mencoder&#x2F;ffmpeg，一个命令动辄3、4行的，要修改其中的参数，这个方法最合适不过了，保存退出后自动执行这个程序。</p>
<p>实际上这是<a target="_blank" rel="noopener" href="http://tiswww.case.edu/php/chet/readline/rltop.html">readline库</a>的功能，在默认情况下，bash使用的是emacs模式的命令行操作方式，<CTRL-x CTRL-e>是调用这个功能的一个绑定。如果你习惯使用vi模式，按<ESC v>可以实现同样功能。</p>
<p>如果你喜欢别的编辑器，可以在~&#x2F;.bashrc里面放上比如export EDITOR&#x3D;nano的命令。</p>
<p>另外一个修改命令的方法是使用fc命令（Fix Command），在编辑器里面打开上一句命令。我们的<a target="_blank" rel="noopener" href="http://www.isspy.com/most_useful_linux_commands_1/">第一辑连载</a>提过一个^foo^bar^命令可以用fc来实现：fc -s foo&#x3D;bar。</p>
<h2 id="2-清空或创建一个文件"><a href="#2-清空或创建一个文件" class="headerlink" title="2.清空或创建一个文件"></a>2.清空或创建一个文件</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>&gt;</strong> file.txt</th>
</tr>
</thead>
</table>
<p>&gt;在shell里面是标准输出重定向符，即把（前部个命令的）命令行输出转往一个文件内，但这里没有“前部命令”，输出为空，于是就覆盖（或创建）成一个空文件了。</p>
<p>有些脚本的写法是:&gt;file.txt，因为:是bash默认存在的空函数。</p>
<p>单纯创建文件也可以用$touch file.txt，touch本来是用作修改文件的时间戳，但如果文件不存在，就自动创建了。</p>
<h2 id="3-用ssh创建端口转发通道"><a href="#3-用ssh创建端口转发通道" class="headerlink" title="3.用ssh创建端口转发通道"></a>3.用ssh创建端口转发通道</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -N  -L2001:remotehost:80 user**@**somemachine</th>
</tr>
</thead>
</table>
<p>这个命令在本机打开了2001端口，对本机2001端口的请求通过somemachine作为跳板，转到remotehost的80端口上。</p>
<p>实现效果跟术语反向代理是相似的，实际上就是端口转发，注意上面的描述涉及了3台主机，但当然somemachine可以变成localhost。</p>
<p>这个命令比较抽象，但有时候是很有用的，比如因为众所周知的原因国内的IP的80端口无法使用，又或者公司的防火墙只给外网开了ssh端口，需要访问内部服务器一个web应用，以及需要访问某些限定了来源IP的服务，就可以用上这个方法了。</p>
<p>举一个具体例子，运行：</p>
<table>
<thead>
<tr>
<th>1  2</th>
<th><strong>ssh</strong> -f -N -L  0.0.0.0:443:twitter.com:443 shell.cjb.net  <strong>ssh</strong> -f -N -L  0.0.0.0:80:twitter.com:80 shell.cjb.net</th>
</tr>
</thead>
</table>
<p>然后在&#x2F;etc&#x2F;hosts里面添加127.0.0.1 twitter.com，好吧剩下的你懂的。</p>
<p>当然通常做这个功能的反向代理，应该要用squid、nginx之类，ssh就算是轻量级的尝试吧！</p>
<h2 id="4-重置终端"><a href="#4-重置终端" class="headerlink" title="4.重置终端"></a>4.重置终端</h2><table>
<thead>
<tr>
<th>1</th>
<th>reset</th>
</tr>
</thead>
</table>
<p>如果你试过不小心cat了某个二进制文件，很可能整个终端就傻掉了，可能不会换行，没法回显，大堆乱码之类的，这时候敲入reset回车，不管命令有没有显示，就能回复正常了。</p>
<p>实际上reset命令只是输出了一些特殊字符，我们看BusyBox里面最简单的reset程序的实现：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>printf(“<strong>\033</strong>c**\033**(K**\033**[J**\033**[0m**\033**[?25h”);</th>
</tr>
</thead>
</table>
<p>输出的这些字符对Shell是有特殊意义的：</p>
<p>·    \033c: “ESC c” – 发送重置命令;</p>
<p>·    \033(K: “ESC ( K” – 重载终端的字符映射;</p>
<p>·    \033[J: “ESC [ J” – 清空终端内容;</p>
<p>·    \033[0m: “ESC [ 0 m” – 初始化字符显示属性;</p>
<p>·    \033[?25h: “ESC [ ? 25 h” – 让光标可见;</p>
<p>其中<em>字符显示属性</em>经常用来设定打印字符的颜色等，可参考<a target="_blank" rel="noopener" href="http://linuxshellaccount.blogspot.com/2008/03/using-color-in-linux-or-unix-shell.html">这个博文</a>。</p>
<h2 id="5-在午夜的时候执行某命令"><a href="#5-在午夜的时候执行某命令" class="headerlink" title="5.在午夜的时候执行某命令"></a>5.在午夜的时候执行某命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>echo</strong> cmd <strong>|</strong> at  midnight</th>
</tr>
</thead>
</table>
<p>说的就是at这个组件，通常跟cron相提并论，不过at主要用于定时一次性任务，而cron定时周期性任务。</p>
<p>at的参数比较人性化，跟英语语法一样，可以tomorrow, next week之类的，详细的查看手册man at。</p>
<h2 id="6-远程传送麦克风语音"><a href="#6-远程传送麦克风语音" class="headerlink" title="6.远程传送麦克风语音"></a>6.远程传送麦克风语音</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>dd</strong> if&#x3D;**&#x2F;<strong>dev</strong>&#x2F;<strong>dsp  <strong>|</strong> <strong>ssh</strong>  username</strong>@<strong>host <strong>dd</strong> of&#x3D;</strong>&#x2F;<strong>dev</strong>&#x2F;**dsp</th>
</tr>
</thead>
</table>
<p>没错就是实现一个喊话器的功能。</p>
<p>&#x2F;dev&#x2F;dsp是Linux下声卡的文件映射（Digital Signal Proccessor），从其中读数据就是录音，往里面写数据就是播放，相当简单！</p>
<p>dd是常用的数据拷贝程序，如果不同时指定if、of，就直接使用stdin&#x2F;stdout来传输。</p>
<p>如果你没有远程主机，可以试试这样：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>dd</strong> if&#x3D;**&#x2F;<strong>dev</strong>&#x2F;<strong>dsp  of&#x3D;</strong>&#x2F;<strong>dev</strong>&#x2F;**dsp</th>
</tr>
</thead>
</table>
<p>直接回放麦克风的声音，只是有一点延时。</p>
<p>但是如果有别的程序正在使用声卡，这个方法就不凑效了，因为一般的声卡都不允许多个音频流同时处理，可以借用alsa组件的工具，arecord跟aplay:</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>arecord</strong> <strong>|</strong> <strong>ssh</strong> username**@**host  <strong>aplay</strong></th>
</tr>
</thead>
</table>
<p>本地回放就是：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>arecord</strong> <strong>|</strong> <strong>aplay</strong></th>
</tr>
</thead>
</table>
<p>如果你想吓吓别人：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>cat</strong> **&#x2F;<strong>dev</strong>&#x2F;<strong>urandom <strong>|</strong>  <strong>ssh</strong> username</strong>@**host <strong>aplay</strong></th>
</tr>
</thead>
</table>
<h2 id="7-映射一个内存目录"><a href="#7-映射一个内存目录" class="headerlink" title="7.映射一个内存目录"></a>7.映射一个内存目录</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>mount</strong> -t tmpfs -o size&#x3D;1024m  tmpfs **&#x2F;<strong>mnt</strong>&#x2F;**ram</th>
</tr>
</thead>
</table>
<p>这个命令开了一块1G内存来当目录用。不过放心，如果里面没文件，是不会占用内存的，用多少占多少。</p>
<p>不过一般来说没必要手动挂载，因为多数发行版都会在fstab内预留了一个内存目录，挂载在&#x2F;dev&#x2F;shm，直接使用即可；</p>
<p>最常见的用途是用内存空间来放Firefox的配置，可以让慢吞吞的FF快很多，参见Shellex的博文：<a target="_blank" rel="noopener" href="http://shellex.info/speeding-up-firefox-with-tmpfs/">用tmpfs让Firefox在内存中飞驰</a>，以及后来的改进：<a target="_blank" rel="noopener" href="http://shellex.info/speeding-up-firefox-with-tmpfs-ii/">用tmpfs让Firefox在内存中飞驰II</a>，其中提到的脚本来自<a target="_blank" rel="noopener" href="http://www.linuxized.com/2009/05/speeding-up-firefox-with-tmpfs-and-automatic-rsync/">speeding up firefox with tmpfs and automatic rsync</a>。</p>
<p>那个破烂LinuxQQ也可以用这个方法，减少因为大量磁盘IO导致的问题。</p>
<h2 id="8-用diff对比远程文件跟本地文件"><a href="#8-用diff对比远程文件跟本地文件" class="headerlink" title="8.用diff对比远程文件跟本地文件"></a>8.用diff对比远程文件跟本地文件</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> user**@**host <strong>cat</strong> **&#x2F;<strong>path</strong>&#x2F;<strong>to</strong>&#x2F;**remotefile  <strong>|</strong> <strong>diff</strong>  **&#x2F;<strong>path</strong>&#x2F;<strong>to</strong>&#x2F;**localfile -</th>
</tr>
</thead>
</table>
<p>diff通常的用法是从参数读入两个文件，而命令里面的-则是指从stdin读入了。</p>
<p>善用ssh可以让web开发减少很多繁琐，还有比如sshfs，可以从<strong>编辑</strong>**-<strong><strong>上传</strong></strong>-<strong><strong>编辑</strong></strong>-**<strong>上传</strong>的人工循环里面解脱出来。</p>
<h2 id="9-查看系统中占用端口的进程"><a href="#9-查看系统中占用端口的进程" class="headerlink" title="9.查看系统中占用端口的进程"></a>9.查看系统中占用端口的进程</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>netstat</strong> -tulnp</th>
</tr>
</thead>
</table>
<p>Netstat是很常用的用来查看Linux网络系统的工具之一，这个参数可以背下来：</p>
<p>·    -t: 显示TCP链接信息</p>
<p>·    -u: 显示UDP链接信息</p>
<p>·    -l: 显示监听状态的端口</p>
<p>·    -n: 直接显示ip，不做名称转换</p>
<p>·    -p: 显示相应的进程PID以及名称（要root权限）</p>
<p>如果要查看关于sockets更详细占用信息等，可以使用lsof工具。</p>
<h2 id="1-更友好的显示当前挂载的文件系统"><a href="#1-更友好的显示当前挂载的文件系统" class="headerlink" title="1. 更友好的显示当前挂载的文件系统"></a>1. 更友好的显示当前挂载的文件系统</h2><p>| <code>1</code>  | <code>**mount** **|** column -t</code> |<br>| —- | ————————— |</p>
<p>这条命令适用于任何文件系统，column 用于把输出结果进行列表格式化操作，这里最主要的目的是让大家熟悉一下 columnt 的用法。 下面是单单使用 mount 命令的结果：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>$ **mount**`` ``**/**dev**/**root on **/** **type** ext3 **(**rw**)**``**/**proc on **/**proc **type** proc **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3 **(**rw,noatime**)**</code></th>
</tr>
</thead>
</table>
<p>而加了 column -t 命令后就成为这样了：</p>
<p>| <code>1``2``3``4``5</code> | <code>$ **mount** **|** column -t`` ``**/**dev**/**root on **/** **type** ext3 **(**rw**)**``**/**proc on **/**proc **type** proc **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3 **(**rw,noatime**)**</code> |<br>| ————— | ———————————————————— |</p>
<p>另外你可加上列名称来改善输出结果</p>
<p>| <code>1``2``3``4``5``6</code> | <code>$ **(echo** &quot;DEVICE - PATH - TYPE FLAGS&quot; **&amp;&amp;** **mount)** **|** column -t`` ``DEVICE          -  PATH  -   TYPE  FLAGS``**/**dev**/**root         on **/**   **type** ext3  **(**rw**)**``**/**proc           on **/**proc **type** proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3  **(**rw,noatime**)**</code> |<br>| —————— | ———————————————————— |</p>
<p>列2和列4并不是很友好，我们可以用 awk 来再处理一下</p>
<p>| <code>1``2``3``4``5``6</code> | <code>$ **(echo** &quot;DEVICE PATH TYPE FLAGS&quot; **&amp;&amp;** **mount** **|** **awk** &#39;$2=$4=&quot;&quot;;1&#39;**)** **|** column -t`` ``DEVICE          PATH  TYPE  FLAGS``**/**dev**/**root         **/**   ext3  **(**rw**)**``**/**proc           **/**proc proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home **/**home ext3  **(**rw,noatime**)**</code> |<br>| —————— | ———————————————————— |</p>
<p>最后我们可以设置一个别名，为 nicemount</p>
<p>| <code>1</code>  | <code>$ nicemount**()** **{** **(echo** &quot;DEVICE PATH TYPE FLAGS&quot; **&amp;&amp;** **mount** **|** **awk** &#39;$2=$4=&quot;&quot;;1&#39;**)** **|** column -t; **}**</code> |<br>| —- | ———————————————————— |</p>
<p>试一下</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6</code></th>
<th><code>$ nicemount`` ``DEVICE          PATH  TYPE  FLAGS``**/**dev**/**root         **/**   ext3  **(**rw**)**``**/**proc           **/**proc proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home **/**home ext3  **(**rw,noatime**)**</code></th>
</tr>
</thead>
</table>
<h2 id="2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”"><a href="#2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”" class="headerlink" title="2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”"></a>2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**!!**:gs**/**foo**/**bar</code></th>
</tr>
</thead>
</table>
<p><code>!!</code> 表示重复执行上一条命令，并用 <code>:gs/foo/bar</code> 进行替换操作。 关于 <code>!!</code> 这个用法在<a target="_blank" rel="noopener" href="http://www.isspy.com/most_useful_linux_commands_1/">前一篇文章中</a>已有详细的介绍。</p>
<h2 id="3-实时某个目录下查看最新改动过的文件"><a href="#3-实时某个目录下查看最新改动过的文件" class="headerlink" title="3. 实时某个目录下查看最新改动过的文件"></a>3. 实时某个目录下查看最新改动过的文件</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**watch** -d -n 1 &#39;df; ls -FlAt /path&#39;</code></th>
</tr>
</thead>
</table>
<p>watch 是实时监控工具，-d 参数会高亮显示变化的区域，-n 1 参数表示刷新间隔为 1 秒。 df; ls -FlAt &#x2F;path 运行了两条命令，df 是输出磁盘使用情况，<code>ls -FlAt</code> 则列出 &#x2F;path 下面的所有文件。 ls -FlAt 的参数详解：</p>
<p>·    -F 在文件后面加一个文件符号表示文件类型，共有 <em>&#x2F;&#x3D;&gt;@|</em> <em>这几种类型，</em> 表示可执行文件，&#x2F; 表示目录，&#x3D; 表示接口( sockets) ，&gt; 表示门， @ 表示符号链接， | 表示管道。</p>
<p>·    -l 以列表方式显示</p>
<p>·    -A 显示 <code>.</code> 和 <code>..</code></p>
<p>·    -t 根据时间排序文件</p>
<h2 id="4-通过-SSH-挂载远程主机上的文件夹"><a href="#4-通过-SSH-挂载远程主机上的文件夹" class="headerlink" title="4. 通过 SSH 挂载远程主机上的文件夹"></a>4. 通过 SSH 挂载远程主机上的文件夹</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>sshfs name**@**server:**/**path**/**to**/**folder **/**path**/**to**/**mount**/**point</code></th>
</tr>
</thead>
</table>
<p>这条命令可以让你通过 SSH 加载远程主机上的文件系统为本地磁盘，前提是你需要安装 FUSE 及 sshfs 这两个软件。 <strong>译者注</strong>：关于 sshfs 实际上我之前写过一篇文章介绍过，详见<a target="_blank" rel="noopener" href="http://wowubuntu.com/sshfs.html">在 Ubuntu 上使用 sshfs 映射远程 ssh 文件系统为本地磁盘</a>。 卸载的话使用 fusermount 或 umount 命令：</p>
<table>
<thead>
<tr>
<th><code>1``2</code></th>
<th><code>$ fusermount -u **/**path**/**to**/**mount**/**point``*# umount /path/to/mount/point*</code></th>
</tr>
</thead>
</table>
<h2 id="5-通过-DNS-来读取-Wikipedia-的词条"><a href="#5-通过-DNS-来读取-Wikipedia-的词条" class="headerlink" title="5. 通过 DNS 来读取 Wikipedia 的词条"></a>5. 通过 DNS 来读取 Wikipedia 的词条</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**dig** +short txt .wp.dg.cx</code></th>
</tr>
</thead>
</table>
<p>这也许是最有趣的一条技巧了，David Leadbeater 创建了一个 <a target="_blank" rel="noopener" href="https://dgl.cx/wikipedia-dns">DNS 服务器</a>，通过它当你查询一个 TXT 记录类型时，会返回一条来自于 Wikipedia 的简短的词条文字，这是<a target="_blank" rel="noopener" href="https://dgl.cx/2008/11/wpdns-pres/">他的介绍</a>。 这里有一个样例，来查询 “hacker” 的含义：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8</code></th>
<th><code>$ **dig** +short txt hacker.wp.dg.cx`` ``&quot;Hacker may refer to: Hacker (computer security), someone involved``in computer security/insecurity, Hacker (programmer subculture), a``programmer subculture originating in the US academia in the 1960s,``which is nowadays mainly notable for the free software/” “open``source movement, Hacker (hobbyist), an enthusiastic home computer``hobbyist http://a.vu/w:Hacker&quot;</code></th>
</tr>
</thead>
</table>
<p>这里使用了 dig 命令，这是标准的用来查询 DNS 的系统管理工具，+short 参数是让其仅仅返回文字响应，txt 则是指定查询 TXT 记录类型。 更简单的做法是你可以为这个技巧创建一个函数：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>wiki**()** **{** **dig** +short txt $1.wp.dg.cx; **}**``*#**然后试试吧：*``wiki hacker`` ``&quot;Hacker may refer to: Hacker (computer security), …&quot;</code></th>
</tr>
</thead>
</table>
<p>如果你不想用 dig ，也可以用 host 命令：</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>host -t txt hacker.wp.dg.cx</code></th>
</tr>
</thead>
</table>
<p>另外在Twitter上看过某人的创意，用普通的dns来作为程序版本更新的查询服务器：设定域名<code>software-version-check.example.com</code>的A记录为<code>1.2.40.3</code>，对比自己的版本号，嗯，有更新了！</p>
<h2 id="6-用-Wget-的递归方式下载整个网站"><a href="#6-用-Wget-的递归方式下载整个网站" class="headerlink" title="6. 用 Wget 的递归方式下载整个网站"></a>6. 用 Wget 的递归方式下载整个网站</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup wget --random-wait -nc -q -r -l 0 --reject=html -np -e robots=off -U Mozilla www.example.com &amp;</span><br></pre></td></tr></table></figure>

<p>参数解释： <em>–random-wait</em> <em>等待</em> <em>0.5</em> <em>到</em> <em>1.5</em> <em>秒的时间来进行下一次请求</em> -r 开启递归检索 <em>-e robots&#x3D;off</em> <em>忽略</em> <em>robots.txt</em> -U Mozilla 设置 User-Agent 头为 Mozilla 其它一些有用的参数：</p>
<p>·    –limit-rate&#x3D;20K 限制下载速度为 20K</p>
<p>·    -o logfile.txt 记录下载日志</p>
<p>·    -l 0 删除深度（默认为5）</p>
<p>·    -wait&#x3D;1h 每下载一个文件后等待1小时</p>
<p>-np 不下载父目录 </p>
<p>–reject&#x3D;html 不下载html</p>
<p>-nc 本地已有的不再下载</p>
<h2 id="7-复制最后使用的命令中的参数"><a href="#7-复制最后使用的命令中的参数" class="headerlink" title="7. 复制最后使用的命令中的参数"></a>7. 复制最后使用的命令中的参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + . or ESC + . </span><br><span class="line">command + . //macOS</span><br></pre></td></tr></table></figure>

<p>这个快捷键只能工作于 shell 的 emacs 编辑模式，它可以从最后使用的命令行中复制参数到当前命令行中，下面是一个样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** c</code></th>
</tr>
</thead>
</table>
<p>你可以重复执行该快捷键，以便获取自已需要的参数， 以下是样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8``9``10</code></th>
<th><code>$ **echo** 1 2 3``1 2 3``$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** c`` ``$ **echo** again``$ **echo** 3</code></th>
</tr>
</thead>
</table>
<p>另外，假如你想指定第1个或第2个，或者是第 n 个参数的话，可以按 ALT + 1 (或 ESC + 1) 或 ALT + 2 (或 ESC +2) 这样形式的快捷键。 以下是样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8``9``10</code></th>
<th><code>$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** a``a`` ``$ **echo**``$ **echo** b``b</code></th>
</tr>
</thead>
</table>
<p>查看<a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/bash-emacs-editing-mode-cheat-sheet/">Emacs Editing Mode Keyboard Shortcuts</a>一文获取更多类似的快捷键。</p>
<h2 id="8-执行一条命令但不保存到-history-中"><a href="#8-执行一条命令但不保存到-history-中" class="headerlink" title="8. 执行一条命令但不保存到 history 中"></a>8. 执行一条命令但不保存到 history 中</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>$ **command**</code></th>
</tr>
</thead>
</table>
<p>这条命令可运行于最新的 Bash shell 里，在其它 shell 中没测试过。 通过在命令行前面添加一个空格，就可以阻止这条命令被保存到 bash history (~&#x2F;.bash_history) 文件中，这个行为可以通过 $HISTIGNORE shell 变量来控制。我的设置是 HISTIGNORE&#x3D;”&amp;:[ ]*” ，表示不保存重复的命令到 history 中，并且不保存以空格开头的命令行。$HISTIGNORE 中的值以冒号分隔。 如果你的命令内包含密码，比如<code>mysqladmin</code>，不把它记录在历史当中是好主义。 深入了解的话，可进一步看此文<a target="_blank" rel="noopener" href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/">The Definitive Guide to Bash Command Line History</a></p>
<h2 id="9-显示当前目录中所有子目录的大小-du"><a href="#9-显示当前目录中所有子目录的大小-du" class="headerlink" title="9. 显示当前目录中所有子目录的大小 du"></a>9. 显示当前目录中所有子目录的大小 du</h2><table>
<thead>
<tr>
<th>sudo du –max-depth&#x3D;1 -BG &#x2F;&#x2F;单位 block-size G;  or  -BM MB</th>
<th>du -h –max-depth&#x3D;1</th>
</tr>
</thead>
</table>
<p>–max-depth&#x3D;1 参数可以让 du 命令显示当前目录下 1 级子目录的统计信息，当然你也可以把 1 改为 2 ，进一步显示 2 级子目录的统计信息，可以灵活运用。而 -h 参数则是以 Mb 、G 这样的单位来显示大小。 <strong>译者注</strong>：在此推荐一个小工具 ncdu ，可以更方便的达到此效果。</p>
<p> 按单位大小排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#du -sh * | sort -hr | head</span><br><span class="line">1.8T	anolis_yum</span><br><span class="line">1.6T	u02</span><br><span class="line">1.5T	os</span><br><span class="line">45G	drds_image</span><br><span class="line">23G	polarx</span><br><span class="line">8.3G	src</span><br><span class="line">7.9G	drds.pcap</span><br><span class="line">7.8G	root</span><br><span class="line">4.3G	core.24086</span><br><span class="line">3.5G	core.112462</span><br></pre></td></tr></table></figure>



<h2 id="10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序"><a href="#10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序" class="headerlink" title="10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序"></a>10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序</h2><p>| <code>1</code>  | <code>**ps** aux **|** **sort** -nk +4 **|** **tail**</code> |<br>| —- | ————————————————- |</p>
<p>显然这并不是最好的方法，但它确实用起还不错。 这是一个典型的管道应用，通过 ps aux 来输出到 sort 命令，并用 sort 排序列出 4 栏，再进一步转到 tail 命令，最终输出 10 行显示使用内存最多的进程情况。 假如想要发现哪个进程使用了大量内存的话，我通常会使用 htop 或 top 而非 ps 。</p>
<h2 id="11-用-python-快速开启一个-SMTP-服务"><a href="#11-用-python-快速开启一个-SMTP-服务" class="headerlink" title="11. 用 python 快速开启一个 SMTP 服务"></a>11. 用 python 快速开启一个 SMTP 服务</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>python -m smtpd -n -c DebuggingServer localhost:1025</code></th>
</tr>
</thead>
</table>
<p>这是一个用 Python 标准库 smtpd （用 -m smtpd 指定) 实现在简易 SMTP 服务，运行于 1025 端口 。 另外三个参数的解释： <em>-n</em> <em>参数让</em> <em>Python</em> <em>不要进行</em> <em>setuid (</em> <em>改变用户）为</em> <em>“nobody”</em> <em>，也就是说直接用你的帐号来运行</em> -c DebuggingServer 参数是让 Python 运行时在屏幕上输出调试及运行信息 * localhost:1025 参数则是让 Python 在本地的 1025 端口上开启 SMTP 服务 另外，假如你想让程序运行于标准的 25 的端口上的话，你必须使用 sudo 命令，因为只有 root 才能在 1-1024 端口上开启服务。如下：</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**sudo** python -m smtpd -n -c DebuggingServer localhost:25</code></th>
</tr>
</thead>
</table>
<p>1.查看ascii码表</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>man</strong> 7 ascii</th>
</tr>
</thead>
</table>
<p>很多人初学编程都会接触到ascii码的概念，有时候为了查某个符号的ascii值，可能还得翻箱倒柜找出当年的课本？<a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/">Linux Manpage</a>里面其实包含了很多类似的实用资料，上述命令就能很详细的方式解释ascii编码，<a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/ascii.7.html">当然这里还有在线版</a>。</p>
<p>man命令的第二个参数是区域码，用来区分索引词的范围，比如printf，在C标准库里面的printf跟bash当中的printf是不同的，前者的查询是man 3 printf，后者是man 1 printf。如果这个区域码省略，就会从1开始搜索，直到找到为止。</p>
<p>命令man man可以<a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/man-pages.7.html">看到详细的解释</a>。</p>
<p>manpages里面还有一些有趣而且实用的资料，可能鲜为人知：</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man1/intro.1.html">man 1 intro </a>– 一篇对从未接触过Linux的用户的简明教程。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man2/syscalls.2.html">man 2 syscalls </a>– 内核系统请求的列表，按内核版本注释分类，系统编程必备。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man2/select_tut.2.html">man 2 select_tut </a>– 关于select()系统请求的教程。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man3/string.3.html">man 3 string </a>– 在头文件内的所有函数。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man3/stdio.3.html">man 3 stdio </a>– 关于头文件的使用，标准输入&#x2F;输出库的说明。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man3/errno.3.html">man 3 errno </a>– 所有errorno的取值及说明。（C语言内类似其他语言的异常告知机制）</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man4/console_codes.4.html">man 4 console_codes </a>– Linux的终端控制码及其使用解释。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man4/full.4.html">man 4 full </a>– 介绍&#x2F;dev&#x2F;full这个总是处于“满”状态的磁盘。（对应&#x2F;dev&#x2F;null这个总是空的设备）</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html">man 5 proc </a>– 介绍&#x2F;proc下的文件系统。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man5/filesystems.5.html">man 5 filesystems </a>– 各种Linux文件系统。</p>
<p>第7区里面的资料通常最酷：</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/bootparam.7.html">man 7 bootparam </a>– 详细解释内核启动参数。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/charsets.7.html">man 7 charsets </a>– 解释各种语言的编码集。（gbk，gb2312等）</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/glob.7.html">man 7 glob </a>– 解释glob文件名管理机制的工作过程。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/hier.7.html">man 7 hier </a>– 解释Linux文件系统结构各个部分的作用。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/operator.7.html">man 7 operator </a>– C语言的运算符的列表。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/regex.7.html">man 7 regex </a>– 介绍正则表达式。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/suffixes.7.html">man 7 suffixes </a>– 常见文件后缀名的列表跟解释。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/time.7.html">man 7 time </a>– Linux的时钟机制解释。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/units.7.html">man 7 units </a>– 数值单位及其数值的解释。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/utf8.7.html">man 7 utf8 </a>– 描述UTF-8编码。</p>
<p>·    <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man7/url.7.html">man 7 url </a>– 解释URL、URI、URN等的标准。</p>
<p>2.简易计时器</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>time</strong> <strong>read</strong></th>
</tr>
</thead>
</table>
<p>运行命令开始算起，到结束时按一下Enter，就显示出整个过程的时间，精确到ms级别。</p>
<p>time是用来计算一个进程在运行到结束过程耗费多少时间的程序，它的输出通常有三项：</p>
<table>
<thead>
<tr>
<th>1  2  3  4  5</th>
<th>$ time ls &#x2F;opt  …  real    0m0.008s  user    0m0.003s  sys    0m0.007s</th>
</tr>
</thead>
</table>
<p>real指整个程序对真实世界而言运行所需时间，user指程序在用户空间运行的时间，sys指程序对系统调用锁占用时间。</p>
<p>read本来是一个读取用户输入的命令，常见用法是read LINE，用户输入并回车后，键入的内容就被保存到$LINE变量内，但在键入回车前，这个命令是一直阻塞的。</p>
<p>可见time read这命令灵活地利用了操作系统的阻塞。用这个命令来测试一壶水多久煮滚应该是不错的。</p>
<p>3.远程关掉一台Windows机器</p>
<table>
<thead>
<tr>
<th>1</th>
<th>net rpc shutdown -I  IP_ADDRESS -U username**%**password</th>
</tr>
</thead>
</table>
<p>Windows平台上的net命令是比较强大的，因为其后台是一个RPC类的系统服务，大家应该看过win下用net use \ip\ipc$ *这样一个命令建立IPC空连接，入侵主机的事情。</p>
<p>Linux下的net命令是samba组件的程序，通常包含在smbclient内，可以跟windows主机的文件、打印机共享等服务进行通讯，但是也支持rpc命令。</p>
<p>上述命令就是在远程Windows主机上执行了shutdown命令。当然这不一定成功，关系到win主机上面的安全设置。net命令能够控制到win主机就是了。</p>
<h2 id="4-在一个子shell中运行一个命令"><a href="#4-在一个子shell中运行一个命令" class="headerlink" title="4.在一个子shell中运行一个命令"></a>4.在一个子shell中运行一个命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>(cd</strong> **&#x2F;**tmp <strong>&amp;&amp;</strong> <strong>ls)</strong></th>
</tr>
</thead>
</table>
<p>当然这只是演示，要查看目录当然可以ls &#x2F;tmp。</p>
<p>好处就是不会改变当前shell的目录，以及如果命令中设计环境变量，也不会对当前shell有任何修改。</p>
<p>在Shell编程中还有很多使用上引号来括住一个命令：<code>ls /tmp</code>，这也是子shell过程。可是上引号的方法无法嵌套，而使用小括号的方法可以，一个比较纠结的例子是：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>echo</strong> $<strong>(echo</strong> -e \x$<strong>(printf</strong>  “%x” 65**))**</th>
</tr>
</thead>
</table>
<p>5.利用中间管道嵌套使用SSH</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -t host_A <strong>ssh</strong> host_B</th>
</tr>
</thead>
</table>
<p>如果目标机器host_B处于比较复杂的网络环境，本机无法直接访问，但另外一台host_A能够访问到host_B，而且也能被本机访问到，那上述命令就解决了方便登录host_B的问题。</p>
<p>但理论上这个过程是可以无限嵌套的，比如：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -t host1 <strong>ssh</strong> -t  host2 <strong>ssh</strong> -t  host3 <strong>ssh</strong> -t  host4 …</th>
</tr>
</thead>
</table>
<p>嗯那神马FBI CIA的，有本事来捉我吧～</p>
<p>6.清空屏幕</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>&lt;**CTRL+l**&gt;</strong>;</th>
</tr>
</thead>
</table>
<p>这个跟之前介绍的reset命令重置终端的作用有些类似，其实都只是发送一段控制序列，让终端的显示复位。</p>
<p>还可以这样运行：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>tput <strong>clear</strong></th>
</tr>
</thead>
</table>
<p>tput是专门用来控制终端的一个小工具，也挺强大的，详细信息运行man tput查看。</p>
<h2 id="7-我想知道一台服务器什么时候重启完"><a href="#7-我想知道一台服务器什么时候重启完" class="headerlink" title="7.我想知道一台服务器什么时候重启完"></a>7.我想知道一台服务器什么时候重启完</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ping</strong> -a IP</th>
</tr>
</thead>
</table>
<p>系统管理员最常做的事情是重启系统。但是服务器的重启过程往往得花上好几分钟，什么你的服务器4个scsi卡？16个硬盘？系统是Redhat？还完全安装所有组件？好吧，它重启的时间都够你吃顿饭了，所以我很想知道它什么时候回来。</p>
<p>ping命令有个audible ping参数，-a，当它终于ping通你的服务器时会让小喇叭叫起来。</p>
<h2 id="8-列出你最常用的10条命令"><a href="#8-列出你最常用的10条命令" class="headerlink" title="8.列出你最常用的10条命令"></a>8.列出你最常用的10条命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>history</strong> <strong>|</strong> <strong>awk</strong> ‘{a[$2]++}END{for(i  in a){print a[i] “ “ i}}’ <strong>|</strong>  <strong>sort</strong> -rn  <strong>|</strong> <strong>head</strong></th>
</tr>
</thead>
</table>
<p>这行命令组合得很妙：</p>
<p>history输出用户了命令历史；awk统计并输出列表；sort排序；head截出前10行。</p>
<h2 id="9-检查Gmail新邮件"><a href="#9-检查Gmail新邮件" class="headerlink" title="9.检查Gmail新邮件"></a>9.检查Gmail新邮件</h2><table>
<thead>
<tr>
<th>1  2  3  4  5  6</th>
<th>curl -u you**@**gmail.com –silent  “<a target="_blank" rel="noopener" href="https://mail.google.com/mail/feed/atom">https://mail.google.com/mail/feed/atom</a>“  <strong>|</strong>   <strong>perl</strong> -ne  \   ‘      print “Subject: $1 “ if &#x2F;<title>(.+?)&lt;/title&gt;&#x2F;  &amp;&amp; $title++;      print “(from $1)\n” if &#x2F;<email>(.+?)&lt;/email&gt;&#x2F;;   ‘</th>
</tr>
</thead>
</table>
<p>Gmail的一个特色是支持Atom feed输出邮件列表，所以总是见到很多Gmail邮件提醒器之类的，因为开发特简单，atom很方便。</p>
<p>这里只是利用了perl的正则来解析atom（sed&#x2F;awk也能做到）。</p>
<h2 id="10-用Telnet看《星球大战》"><a href="#10-用Telnet看《星球大战》" class="headerlink" title="10.用Telnet看《星球大战》"></a>10.用Telnet看《星球大战》</h2><table>
<thead>
<tr>
<th>1</th>
<th>telnet towel.blinkenlights.nl</th>
</tr>
</thead>
</table>
<p>没什么好解释的，就是ASCII艺术之一。如果你有ipv6连接，还能看到彩色版的。牛吧？</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/shell/" rel="tag"># shell</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/10/12/ss%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/" rel="prev" title="就是要你懂网络监控--ss用法大全">
                  <i class="fa fa-angle-left"></i> 就是要你懂网络监控--ss用法大全
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/01/14/%E9%80%9A%E8%BF%87%E5%88%86%E6%9E%90tcp%E5%8C%85%E6%9D%A5%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/" rel="next" title="通过分析tcp包来确认服务调用的响应时间">
                  通过分析tcp包来确认服务调用的响应时间 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">twitter @plantegg</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
