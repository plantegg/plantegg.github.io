<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"plantegg.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="CPU 性能和Cache Line为了让程序能快点，特意了解了CPU的各种原理，比如多核、超线程、NUMA、睿频、功耗、GPU、大小核再到分支预测、cache_line失效、加锁代价、IPC等各种指标（都有对应的代码和测试数据）都会在这系列文章中得到答案。当然一定会有程序员最关心的分支预测案例、Disruptor无锁案例、cache_line伪共享案例等等。 这次让我们从最底层的沙子开始用8篇文章">
<meta property="og:type" content="article">
<meta property="og:title" content="CPU 性能和Cache Line">
<meta property="og:url" content="https://plantegg.github.io/2021/05/16/CPU_Cache_Line%E5%92%8C%E6%80%A7%E8%83%BD/index.html">
<meta property="og:site_name" content="plantegg">
<meta property="og:description" content="CPU 性能和Cache Line为了让程序能快点，特意了解了CPU的各种原理，比如多核、超线程、NUMA、睿频、功耗、GPU、大小核再到分支预测、cache_line失效、加锁代价、IPC等各种指标（都有对应的代码和测试数据）都会在这系列文章中得到答案。当然一定会有程序员最关心的分支预测案例、Disruptor无锁案例、cache_line伪共享案例等等。 这次让我们从最底层的沙子开始用8篇文章">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20220928160819468.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210914175307651.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image6.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20220613103011120.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/1620984677390-81694fd0-0323-4052-98d1-32be39a02248-4505908.png">
<meta property="og:image" content="https://plantegg.github.io/images/oss/1577093636588-6b58c36c-1617-4f2c-aba9-156c52972689.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/1.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210517111209985.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210517111244550.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210512133536939.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210512132121856.png">
<meta property="article:published_time" content="2021-05-16T04:30:03.000Z">
<meta property="article:modified_time" content="2025-11-16T11:58:49.512Z">
<meta property="article:author" content="twitter @plantegg">
<meta property="article:tag" content="CPU">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="cache_line">
<meta property="article:tag" content="performance">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20220928160819468.png">


<link rel="canonical" href="https://plantegg.github.io/2021/05/16/CPU_Cache_Line%E5%92%8C%E6%80%A7%E8%83%BD/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://plantegg.github.io/2021/05/16/CPU_Cache_Line%E5%92%8C%E6%80%A7%E8%83%BD/","path":"2021/05/16/CPU_Cache_Line和性能/","title":"CPU 性能和Cache Line"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CPU 性能和Cache Line | plantegg</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">plantegg</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">java tcp mysql performance network docker Linux</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU-%E6%80%A7%E8%83%BD%E5%92%8CCache-Line"><span class="nav-number">1.</span> <span class="nav-text">CPU 性能和Cache Line</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0"><span class="nav-number">1.1.</span> <span class="nav-text">系列文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-cache-line"><span class="nav-number">1.2.</span> <span class="nav-text">什么是 cache_line</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-%E5%A4%B1%E6%95%88"><span class="nav-number">1.2.1.</span> <span class="nav-text">cache 失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-cache-line"><span class="nav-number">1.3.</span> <span class="nav-text">查看 cache_line</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cache-line-%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">1.4.</span> <span class="nav-text">cache_line 影响性能的案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E4%B8%8B%E7%9A%84cache-line%E5%BD%B1%E5%93%8D"><span class="nav-number">1.5.</span> <span class="nav-text">四线程竞争下的cache_line影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Disruptor"><span class="nav-number">1.6.</span> <span class="nav-text">Disruptor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Disruptor%E4%B8%AD%E5%AF%B9cache-line%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">Disruptor中对cache_line的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intel-PAUSE%E6%8C%87%E4%BB%A4%E5%8F%98%E5%8C%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E8%87%AA%E6%97%8B%E9%94%81%E4%BB%A5%E5%8F%8AMySQL%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84"><span class="nav-number">1.7.</span> <span class="nav-text">Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pause-%E5%92%8C-spinlock"><span class="nav-number">1.7.1.</span> <span class="nav-text">pause 和 spinlock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ECS-cache-line-miss%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AA%E7%89%A9%E7%90%86%E6%9C%BA%E5%93%8D%E5%BA%94%E6%85%A2"><span class="nav-number">1.8.</span> <span class="nav-text">ECS cache_line miss导致整个物理机响应慢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%AF%B9%E9%BD%90%E8%AE%BF%E9%97%AE%E5%88%B0split-lock"><span class="nav-number">1.8.1.</span> <span class="nav-text">从地址不对齐访问到split lock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E6%A1%88%E4%BE%8B"><span class="nav-number">1.9.</span> <span class="nav-text">分支预测案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-1"><span class="nav-number">1.10.</span> <span class="nav-text">系列文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.11.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">twitter @plantegg</p>
  <div class="site-description" itemprop="description">java mysql tcp performance network docker Linux</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">185</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">274</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2021/05/16/CPU_Cache_Line%E5%92%8C%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twitter @plantegg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
      <meta itemprop="description" content="java mysql tcp performance network docker Linux">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CPU 性能和Cache Line | plantegg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CPU 性能和Cache Line
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-16 12:30:03" itemprop="dateCreated datePublished" datetime="2021-05-16T12:30:03+08:00">2021-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-16 19:58:49" itemprop="dateModified" datetime="2025-11-16T19:58:49+08:00">2025-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="CPU-性能和Cache-Line"><a href="#CPU-性能和Cache-Line" class="headerlink" title="CPU 性能和Cache Line"></a>CPU 性能和Cache Line</h1><p>为了让程序能快点，特意了解了CPU的各种原理，比如多核、超线程、NUMA、睿频、功耗、GPU、大小核再到分支预测、cache_line失效、加锁代价、IPC等各种指标（都有对应的代码和测试数据）都会在这系列文章中得到答案。当然一定会有程序员最关心的分支预测案例、Disruptor无锁案例、cache_line伪共享案例等等。</p>
<p>这次让我们从最底层的沙子开始用8篇文章来回答各种疑问以及大量的实验对比案例和测试数据。</p>
<p>大的方面主要是从这几个疑问来写这些文章：</p>
<ul>
<li>同样程序为什么CPU跑到800%还不如CPU跑到200%快？</li>
<li>IPC背后的原理和和程序效率的关系？</li>
<li>为什么数据库领域都爱把NUMA关了，这对吗？</li>
<li>几个国产芯片的性能到底怎么样？</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/">CPU的制造和概念</a></p>
<p>[Perf IPC以及CPU性能](&#x2F;2021&#x2F;05&#x2F;16&#x2F;Perf IPC以及CPU利用率&#x2F;)</p>
<p>[CPU 性能和Cache Line](&#x2F;2021&#x2F;05&#x2F;16&#x2F;CPU Cache Line 和性能&#x2F;)</p>
<p><a href="/2021/05/14/%E5%8D%81%E5%B9%B4%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E4%B8%8D%E6%95%A2%E6%8B%A5%E6%8A%B1NUMA/">十年后数据库还是不敢拥抱NUMA？</a></p>
<p>[Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的](&#x2F;2019&#x2F;12&#x2F;16&#x2F;Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的&#x2F;)</p>
<p><a href="/2021/06/18/%E5%87%A0%E6%AC%BECPU%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/">Intel、海光、鲲鹏920、飞腾2500 CPU性能对比</a></p>
<p><a href="/2021/03/07/%E4%B8%80%E6%AC%A1%E6%B5%B7%E5%85%89%E7%89%A9%E7%90%86%E6%9C%BA%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E5%8E%8B%E6%B5%8B%E7%9A%84%E8%AE%B0%E5%BD%95/">一次海光物理机资源竞争压测的记录</a></p>
<p><a href="/2021/05/15/%E9%A3%9E%E8%85%BEARM%E8%8A%AF%E7%89%87-FT2500%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">飞腾ARM芯片(FT2500)的性能测试</a></p>
<p>CPU为什么要CACHE，请看这篇</p>
<h2 id="什么是-cache-line"><a href="#什么是-cache-line" class="headerlink" title="什么是 cache_line"></a>什么是 cache_line</h2><p>CPU从内存中读取数据的时候是一次读一个cache_line到 cache中以提升效率，一般情况下cache_line的大小是64 byte（64Bytes也就是16个32位的整型）这就是CPU从内存中捞数据上来的最小数据单位，按照热点逻辑还是大概率会依次被访问到（详见后面的例子）。</p>
<p>比如L1 Cache 有32KB，那么它可以分成32KB &#x2F; 64 &#x3D; 512 条 Cache Line。</p>
<p>Cache Line 是 CPU 和主存之间数据传输的最小单位。当一行 Cache Line 被从内存拷贝到 Cache 里，Cache 里会为这个 Cache Line 创建一个条目。这个 Cache 条目里既包含了拷贝的内存数据，即 Cache Line，又包含了这行数据在内存里的位置等元数据信息。</p>
<p>处理器都实现了 Cache 一致性 (Cache Coherence）协议。如历史上 x86 曾实现了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MESI_protocol"> MESI 协议</a>，以及 MESIF 协议。</p>
<p><img src="/images/951413iMgBlog/image-20220928160819468.png" alt="image-20220928160819468"></p>
<p>先看下如上一张图，其中</p>
<p>tag：一般虚拟地址高位多bit表示；</p>
<p>index: 虚拟地址中间多bit表示；</p>
<p>offset: 虚拟地址多bit表示；</p>
<p>但是这三者的值是多少呢，只能说和cache缓存的的大小息息相关。</p>
<p>举个例子，录入cache缓存大小为64K, 有4路， 服务器寻址为64bit。</p>
<ul>
<li>offset的值为 2^ &#x3D; 64; offset &#x3D; 6;</li>
<li>index的值为 64k &#x2F; (64 * 4) &#x3D; 256 &#x3D; 2 ^ 8; 所以index的值为8bit；</li>
<li>tag的值为 64 - 8 - 6 &#x3D; 50bit;</li>
</ul>
<p>注:此计算完全按照理论方式计算，实际情况需要考虑TLB别名以及其他情况影响。</p>
<p>了解以上概念后，此处用一张图去介绍TLB转换获取数据的过程。</p>
<h3 id="cache-失效"><a href="#cache-失效" class="headerlink" title="cache 失效"></a>cache 失效</h3><p>假设两个处理器 A 和 B, 都在各自本地 Cache Line 里有同一个变量的拷贝时，此时该 Cache Line 处于 Shared 状态。当处理器 A 在本地修改了变量，除去把本地变量所属的 Cache Line 置为 Modified 状态以外，还必须在另一个处理器 B 读同一个变量前，对该变量所在的 B 处理器本地 Cache Line 发起 Invaidate 操作，标记 B 处理器的那条 Cache Line 为 Invalidate 状态。随后，若处理器 B 在对变量做读写操作时，如果遇到这个标记为 Invalidate 的状态的 Cache Line，即会引发 Cache Miss，从而将内存中最新的数据拷贝到 Cache Line 里，然后处理器 B 再对此 Cache Line 对变量做读写操作。</p>
<p>cache ping-pong(cache-line ping-ponging) 是指不同的CPU共享位于同一个cache-line里边的变量，当不同的CPU频繁的对该变量进行读写时，会导致其他CPU cache-line的失效。</p>
<p>显而易见的是一旦cache失效就需要访问内存重新从内存中读取数据到CPU cache中，这个过程会很慢。</p>
<h2 id="查看-cache-line"><a href="#查看-cache-line" class="headerlink" title="查看 cache_line"></a>查看 cache_line</h2><p>如下 Linux <code>getconf</code> 命令的输出，除了 <code>*_LINESIZE</code> 指示了系统的 Cache Line 的大小是 64 字节外，还给出了 Cache 类别，大小。 其中 <code>*_ASSOC</code> 则指示了该 Cache 是几路关联 (Way Associative) 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$sudo getconf -a |grep CACHE</span><br><span class="line">LEVEL1_ICACHE_SIZE                 32768</span><br><span class="line">LEVEL1_ICACHE_ASSOC                8</span><br><span class="line">LEVEL1_ICACHE_LINESIZE             64</span><br><span class="line">LEVEL1_DCACHE_SIZE                 32768</span><br><span class="line">LEVEL1_DCACHE_ASSOC                8</span><br><span class="line">LEVEL1_DCACHE_LINESIZE             64</span><br><span class="line">LEVEL2_CACHE_SIZE                  262144</span><br><span class="line">LEVEL2_CACHE_ASSOC                 4</span><br><span class="line">LEVEL2_CACHE_LINESIZE              64</span><br><span class="line">LEVEL3_CACHE_SIZE                  3145728</span><br><span class="line">LEVEL3_CACHE_ASSOC                 12</span><br><span class="line">LEVEL3_CACHE_LINESIZE              64</span><br><span class="line">LEVEL4_CACHE_SIZE                  0</span><br><span class="line">LEVEL4_CACHE_ASSOC                 0</span><br><span class="line">LEVEL4_CACHE_LINESIZE              0</span><br></pre></td></tr></table></figure>

<p>比如，对于下面的FT2500 ARM芯片下，L1D是32K，是因为32K&#x3D;256*2*64（64就是cache_line大小，16个int）, 这32K是256个组，每组2行（x86一般是每组8行），每行就是一个cache_line</p>
<p><img src="/images/951413iMgBlog/image-20210914175307651.png" alt="image-20210914175307651"></p>
<h2 id="cache-line-影响性能的案例"><a href="#cache-line-影响性能的案例" class="headerlink" title="cache_line 影响性能的案例"></a>cache_line 影响性能的案例</h2><p>如下两个循环执行次数循环2是循环1的十六分之一。但是在x86和arm下执行时间都是循环2是循环1的四分之一左右。</p>
<p>之所以执行时间不是十六分之一是因为循环一重用了cache_line. </p>
<p>Xeon(R) Platinum 8260跑这个程序的性能是鲲鹏920的2倍左右。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">long timediff(clock_t t1, clock_t t2) &#123;</span><br><span class="line">    long elapsed;</span><br><span class="line">    elapsed = ((double)t2 - t1) / CLOCKS_PER_SEC * 1000;</span><br><span class="line">    return elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	long length=64*1024*1024;</span><br><span class="line">	int* arr=malloc(64*1024*1024 * sizeof(int));</span><br><span class="line">	long i=0;</span><br><span class="line">	long j=0;</span><br><span class="line">	for (i = 0; i &lt; length; i++) arr[i] = i;</span><br><span class="line"></span><br><span class="line">	clock_t start=clock();</span><br><span class="line">	// 循环1</span><br><span class="line">	for(j=0; j&lt;10; j++)&#123;</span><br><span class="line">	    for (i = 0; i &lt; length; i++) arr[i] *= 3; //每取一次arr[i], 通过cache_line顺便把后面15个arr[i]都取过来了</span><br><span class="line">	&#125;</span><br><span class="line">  clock_t end =clock();</span><br><span class="line">	printf(&quot;%lu\n&quot;, timediff(start,end));</span><br><span class="line"></span><br><span class="line">  start=clock();</span><br><span class="line">	// 循环2</span><br><span class="line">	for(j=0; j&lt;10; j++)&#123;</span><br><span class="line">	    for (i = 0; i &lt; length; i += 16) arr[i] *= 3;</span><br><span class="line">	&#125;</span><br><span class="line">  end =clock();</span><br><span class="line">  printf(&quot;%lu\n&quot;, timediff(start,end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鲲鹏920上循环一的perf结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#perf stat -- ./cache_line_loop.out</span><br><span class="line">2790</span><br><span class="line"></span><br><span class="line">failed to read counter branches</span><br><span class="line"></span><br><span class="line"> Performance counter stats for &#x27;./cache_line_loop.out&#x27;:</span><br><span class="line"></span><br><span class="line">       3238.892820      task-clock (msec)         #    1.000 CPUs utilized</span><br><span class="line">                 4      context-switches          #    0.001 K/sec</span><br><span class="line">                 0      cpu-migrations            #    0.000 K/sec</span><br><span class="line">            65,582      page-faults               #    0.020 M/sec</span><br><span class="line">     8,420,900,487      cycles                    #    2.600 GHz</span><br><span class="line">        23,284,432      stalled-cycles-frontend   #    0.28% frontend cycles idle</span><br><span class="line">     4,709,527,283      stalled-cycles-backend    #   55.93% backend  cycles idle</span><br><span class="line">    14,553,892,976      instructions              #    1.73  insns per cycle</span><br><span class="line">                                                  #    0.32  stalled cycles per insn //因为有cache_line的命中，stall是循环二的四分之一</span><br><span class="line">   &lt;not supported&gt;      branches</span><br><span class="line">           141,482      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       3.239729660 seconds time elapsed</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>鲲鹏920上循环二的perf结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#perf stat -- ./cache_line_loop.out</span><br><span class="line">730</span><br><span class="line">failed to read counter branches</span><br><span class="line"></span><br><span class="line"> Performance counter stats for &#x27;./cache_line_loop.out&#x27;:</span><br><span class="line"></span><br><span class="line">       1161.126720      task-clock (msec)         #    0.999 CPUs utilized</span><br><span class="line">                 1      context-switches          #    0.001 K/sec</span><br><span class="line">                 0      cpu-migrations            #    0.000 K/sec</span><br><span class="line">            65,583      page-faults               #    0.056 M/sec</span><br><span class="line">     3,018,882,346      cycles                    #    2.600 GHz</span><br><span class="line">        21,846,222      stalled-cycles-frontend   #    0.72% frontend cycles idle</span><br><span class="line">     2,456,150,941      stalled-cycles-backend    #   81.36% backend  cycles idle</span><br><span class="line">     1,970,906,199      instructions              #    0.65  insns per cycle</span><br><span class="line">                                                  #    1.25  stalled cycles per insn</span><br><span class="line">   &lt;not supported&gt;      branches</span><br><span class="line">           138,051      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       1.161791340 seconds time elapsed</span><br></pre></td></tr></table></figure>

<p> 在Xeon(R) Platinum 8260 CPU @ 2.40GHz 上运行上面两个循环的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#perf stat -- ./cache_line_loop.out</span><br><span class="line">1770</span><br><span class="line">370</span><br></pre></td></tr></table></figure>

<p>更多案例请参考7个示例科普CPU CACHE：<a target="_blank" rel="noopener" href="http://igoro.com/archive/gallery-of-processor-cache-effects/">Gallery of Processor Cache Effects</a></p>
<p>如下图，表示的是for循环每次跳K个int，在K小于16的时候虽然循环次数逐渐减少到原来的1&#x2F;16, 但是总时间没变，因为一直是访问的同一个cache里面的数据。 到16个之后就会产生突变（跨了cache_line），再后面32、64、128的时间减少来源于循环次数的减少，因为如论如何每次循环都需要访问内存加载数据到cache_line中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; arr.Length; i += K) arr[i] *= 3;</span><br></pre></td></tr></table></figure>

<p><img src="/images/951413iMgBlog/image6.png" alt="running times of this loop for different step values (K)"></p>
<p>更典型的案例是对一个二维数组逐行遍历和逐列遍历的时间差异，变量次数一样，但是因为二维数组按行保存，所以逐行遍历对cache line 更友好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const int row = 1024;</span><br><span class="line">const int col = 512</span><br><span class="line">int matrix[row][col];</span><br><span class="line">//逐行遍历  0.081ms</span><br><span class="line">int sum_row=0;</span><br><span class="line">for(int _r=0; _r&lt;row; _r++) &#123;</span><br><span class="line">    for(int _c=0; _c&lt;col; _c++)&#123;</span><br><span class="line">        sum_row += matrix[_r][_c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//逐列遍历 1.069ms</span><br><span class="line">int sum_col=0;</span><br><span class="line">for(int _c=0; _c&lt;col; _c++) &#123;</span><br><span class="line">    for(int _r=0; _r&lt;row; _r++)&#123;</span><br><span class="line">        sum_col += matrix[_r][_c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四线程竞争下的cache-line影响"><a href="#四线程竞争下的cache-line影响" class="headerlink" title="四线程竞争下的cache_line影响"></a>四线程竞争下的cache_line影响</h2><p><img src="/images/951413iMgBlog/image-20220613103011120.png" alt="image-20220613103011120"></p>
<p>上图是每个线程对内存中自己的int进行++ (每个线程绑定在自己的core上，机器有4个P4 core)， 蓝色部分是每个线程的变量分配在线程内部，也就是每个变量有独立的cache_line，红色部分(含蓝色)是将变量放在一个cache_line（必然会出现伪共享）</p>
<h2 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a><a target="_blank" rel="noopener" href="https://lmax-exchange.github.io/disruptor/disruptor.html">Disruptor</a></h2><p>Disruptor论文中讲述了我们所做的一个实验。这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。当单线程无锁时，程序耗时300ms。如果增加一个锁（仍是单线程、没有竞争、仅仅增加锁），程序需要耗时10000ms，慢了两个数量级。更令人吃惊的是，如果增加一个线程（简单从逻辑上想，应该比单线程加锁快一倍），耗时224000ms。使用两个线程对计数器自增5亿次比使用无锁单线程慢1000倍。**并发很难而锁的性能糟糕。**单线程使用CAS耗时5700ms。所以它比使用锁耗时少，但比不需要考虑竞争的单线程耗时多。</p>
<p>We will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which increments a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel Westmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar across all languages with the same basic primitives.</p>
<p>Once a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up significantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results of this simple experiment are shown in the table below:</p>
<p><em>Table 1. Comparative costs of contention</em></p>
<table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">Time (ms)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Single thread</td>
<td align="left">300</td>
</tr>
<tr>
<td align="left">Single thread with lock</td>
<td align="left">10,000</td>
</tr>
<tr>
<td align="left">Two threads with lock</td>
<td align="left">224,000</td>
</tr>
<tr>
<td align="left">Single thread with CAS</td>
<td align="left">5,700</td>
</tr>
<tr>
<td align="left">Two threads with CAS</td>
<td align="left">30,000</td>
</tr>
<tr>
<td align="left">Single thread with volatile write</td>
<td align="left">4,700</td>
</tr>
</tbody></table>
<p>如下测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class LockBenchmark&#123;</span><br><span class="line">    public static void runIncrement()</span><br><span class="line">    &#123;</span><br><span class="line">        long counter = 0;</span><br><span class="line">        long max  = 50000000000L;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while (counter &lt; max) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Time spent is &quot; + (end-start) + &quot;ms without lock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void runIncrementWithLock()</span><br><span class="line">    &#123;</span><br><span class="line">        Lock lock = new ReentrantLock();</span><br><span class="line">        long counter = 0;</span><br><span class="line">        long max = 500000000L;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while (counter &lt; max) &#123;</span><br><span class="line">            if (lock.tryLock())&#123;</span><br><span class="line">                counter++;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Time spent is &quot; + (end-start) + &quot;ms with lock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        runIncrement();</span><br><span class="line">	      System.out.println(&quot;start runIncrementWithLock.&quot;);</span><br><span class="line">        runIncrementWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@ARM 14:14 /root]</span><br><span class="line">#java test.LockBenchmark</span><br><span class="line">Time spent is 19261ms without lock</span><br><span class="line">start runIncrementWithLock.</span><br><span class="line">Time spent is 17267ms with lock</span><br><span class="line"></span><br><span class="line">//单线程加锁在没有任何竞争的情况下慢了两个数量级是因为加锁动作本身需要几十个指令</span><br><span class="line">reentrantLock.tryLock()实现：</span><br><span class="line"> 11   final boolean nonfairTryAcquire(int);</span><br><span class="line"> 12     Code:</span><br><span class="line"> 13        0: invokestatic  #2                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line"> 14        3: astore_2</span><br><span class="line"> 15        4: aload_0</span><br><span class="line"> 16        5: invokevirtual #3                  // Method getState:()I</span><br><span class="line"> 17        8: istore_3</span><br><span class="line"> 18        9: iload_3</span><br><span class="line"> 19       10: ifne          29</span><br><span class="line"> 20       13: aload_0</span><br><span class="line"> 21       14: iconst_0</span><br><span class="line"> 22       15: iload_1</span><br><span class="line"> 23       16: invokevirtual #4                  // Method compareAndSetState:(II)Z</span><br><span class="line"> 24       19: ifeq          65</span><br><span class="line"> 25       22: aload_0</span><br><span class="line"> 26       23: aload_2</span><br><span class="line"> 27       24: invokevirtual #5                  // Method setExclusiveOwnerThread:(Ljava/lang/Thread;)V</span><br><span class="line"> 28       27: iconst_1</span><br><span class="line"> 29       28: ireturn</span><br><span class="line"> 30       29: aload_2</span><br><span class="line"> 31       30: aload_0</span><br><span class="line"> 32       31: invokevirtual #6                  // Method getExclusiveOwnerThread:()Ljava/lang/Thread;</span><br><span class="line"> 33       34: if_acmpne     65</span><br><span class="line"> 34       37: iload_3</span><br><span class="line"> 35       38: iload_1</span><br><span class="line"> 36       39: iadd</span><br><span class="line"> 37       40: istore        4</span><br><span class="line"> 38       42: iload         4</span><br><span class="line"> 39       44: ifge          57</span><br><span class="line"> 40       47: new           #7                  // class java/lang/Error</span><br><span class="line"> 41       50: dup</span><br><span class="line"> 42       51: ldc           #8                  // String Maximum lock count exceeded</span><br><span class="line"> 43       53: invokespecial #9                  // Method java/lang/Error.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line"> 44       56: athrow</span><br><span class="line"> 45       57: aload_0</span><br><span class="line"> 46       58: iload         4</span><br><span class="line"> 47       60: invokevirtual #10                 // Method setState:(I)V</span><br><span class="line"> 48       63: iconst_1</span><br><span class="line"> 49       64: ireturn</span><br><span class="line"> 50       65: iconst_0</span><br><span class="line"> 51       66: ireturn</span><br></pre></td></tr></table></figure>

<p>不加锁的循环执行500亿次循环，加锁的只执行5亿次，最终耗时差不多。对应两个阶段的IPC数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#perf stat -p 92098</span><br><span class="line"> Performance counter stats for process id &#x27;92098&#x27;:</span><br><span class="line"></span><br><span class="line">       3978.381920      task-clock (msec)         #    1.001 CPUs utilized</span><br><span class="line">               121      context-switches          #    0.030 K/sec</span><br><span class="line">                 7      cpu-migrations            #    0.002 K/sec</span><br><span class="line">                71      page-faults               #    0.018 K/sec</span><br><span class="line">    10,343,414,319      cycles                    #    2.600 GHz</span><br><span class="line">         2,091,748      stalled-cycles-frontend   #    0.02% frontend cycles idle</span><br><span class="line">        11,011,682      stalled-cycles-backend    #    0.11% backend  cycles idle</span><br><span class="line">    41,311,635,225      instructions              #    3.99  insns per cycle      //不加锁循环++</span><br><span class="line">                                                  #    0.00  stalled cycles per insn</span><br><span class="line">   &lt;not supported&gt;      branches</span><br><span class="line">            32,675      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       3.972534070 seconds time elapsed</span><br><span class="line"></span><br><span class="line">[root@ARM 13:55 /root]</span><br><span class="line">#perf stat -p 92098</span><br><span class="line">^Cfailed to read counter branches</span><br><span class="line"></span><br><span class="line"> Performance counter stats for process id &#x27;92098&#x27;:</span><br><span class="line"></span><br><span class="line">      10599.558340      task-clock (msec)         #    1.001 CPUs utilized</span><br><span class="line">               292      context-switches          #    0.028 K/sec</span><br><span class="line">                 1      cpu-migrations            #    0.000 K/sec</span><br><span class="line">               202      page-faults               #    0.019 K/sec</span><br><span class="line">    27,557,631,981      cycles                    #    2.600 GHz</span><br><span class="line">     1,079,785,178      stalled-cycles-frontend   #    3.92% frontend cycles idle</span><br><span class="line">    15,669,652,101      stalled-cycles-backend    #   56.86% backend  cycles idle</span><br><span class="line">    14,456,635,493      instructions              #    0.52  insns per cycle     //加锁循环++</span><br><span class="line">                                                  #    1.08  stalled cycles per insn</span><br><span class="line">   &lt;not supported&gt;      branches</span><br><span class="line">            69,722      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">      10.592190690 seconds time elapsed</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到最终时间差了100倍，IPC差了8倍，从指令数来看加锁后指令数会略多，但是加锁造成了stall（即使没有实际竞争）。</p>
<p>上述代码如果是在：Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz 上运行，差距要小很多，也可以看出intel x86芯片优化比较好。不加锁的循环X86比ARM要慢一点点是因为ARM芯片的主频是2.6G，要高一点点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#java test.LockBenchmark  //x86</span><br><span class="line">Time spent is 20135ms without lock</span><br><span class="line">start runIncrementWithLock.</span><br><span class="line">Time spent is 13056ms with lock</span><br></pre></td></tr></table></figure>

<p><strong>此时Intel CPU上对应的IPC分别是3.99和1.</strong></p>
<p>这里加锁和不加锁最终性能差了将近2个数量级，但是IPC只差了8倍，另外的差异在加锁后增加了很多的指令、函数调用等。如果两个函数都增加每个循环里面的指令数量，那么他们的时间差距会缩小。如果增加的指令是乘法、除法会大幅降低IPC</p>
<p>比如代码改成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#cat LockBenchmark.java</span><br><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class LockBenchmark&#123;</span><br><span class="line">    public static void runIncrement()</span><br><span class="line">    &#123;</span><br><span class="line">        long counter = 0;</span><br><span class="line">        long max  = 500000000L;</span><br><span class="line">				double sum =100.0;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while (counter &lt; max) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">						sum=3.251;</span><br><span class="line">						for(int i=0; i&lt;10; ++i)&#123;</span><br><span class="line">							sum += sum*3.75/3;</span><br><span class="line">						&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Time spent is &quot; + (end-start) + &quot;ms without lock:&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void runIncrementWithLock()</span><br><span class="line">    &#123;</span><br><span class="line">        Lock lock = new ReentrantLock();</span><br><span class="line">        long counter = 0;</span><br><span class="line">				double sum=100.0;</span><br><span class="line">        long max = 500000000L;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while (counter &lt; max) &#123;</span><br><span class="line">            if (lock.tryLock())&#123;</span><br><span class="line">		    			counter++;</span><br><span class="line">							sum=3.253;</span><br><span class="line">							for(int i=0; i&lt;10; ++i)&#123;</span><br><span class="line">								sum += sum*3.75/3;</span><br><span class="line">							&#125;</span><br><span class="line">              lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Time spent is &quot; + (end-start) + &quot;ms with lock:&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        runIncrement();</span><br><span class="line">	    	System.out.println(&quot;start runIncrementWithLock.&quot;);</span><br><span class="line">        runIncrementWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Intel芯片下，加锁运行时间慢了1倍，IPC差不多，运行时间和IPC 分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#java test.LockBenchmark  //如上代码循环次数都是5亿次， intel cpu</span><br><span class="line">Time spent is 11884ms without lock:10810.40962948895</span><br><span class="line">start runIncrementWithLock.</span><br><span class="line">Time spent is 22662ms with lock:10817.060142949109</span><br><span class="line"></span><br><span class="line">#perf stat -p `jps | grep LockBenchmark | awk &#x27;&#123; print $1 &#125;&#x27;`</span><br><span class="line">^C</span><br><span class="line"> Performance counter stats for process id &#x27;117862&#x27;:</span><br><span class="line"></span><br><span class="line">       7144.193030      task-clock (msec)         #    1.002 CPUs utilized            (100.00%)</span><br><span class="line">               227      context-switches          #    0.032 K/sec                    (100.00%)</span><br><span class="line">                26      cpu-migrations            #    0.004 K/sec                    (100.00%)</span><br><span class="line">               199      page-faults               #    0.028 K/sec</span><br><span class="line">    17,842,543,877      cycles                    #    2.497 GHz                      (100.00%)</span><br><span class="line">   &lt;not supported&gt;      stalled-cycles-frontend</span><br><span class="line">   &lt;not supported&gt;      stalled-cycles-backend</span><br><span class="line">    17,153,665,963      instructions              #    0.96  insns per cycle          (100.00%)</span><br><span class="line">     2,408,676,080      branches                  #  337.152 M/sec                    (100.00%)</span><br><span class="line">            39,593      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       7.133030625 seconds time elapsed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#perf stat -p `jps | grep LockBenchmark | awk &#x27;&#123; print $1 &#125;&#x27;`</span><br><span class="line">^C</span><br><span class="line"> Performance counter stats for process id &#x27;117862&#x27;:</span><br><span class="line"></span><br><span class="line">       3962.496661      task-clock (msec)         #    1.002 CPUs utilized            (100.00%)</span><br><span class="line">               123      context-switches          #    0.031 K/sec                    (100.00%)</span><br><span class="line">                 3      cpu-migrations            #    0.001 K/sec                    (100.00%)</span><br><span class="line">                77      page-faults               #    0.019 K/sec</span><br><span class="line">     9,895,900,342      cycles                    #    2.497 GHz                      (100.00%)</span><br><span class="line">   &lt;not supported&gt;      stalled-cycles-frontend</span><br><span class="line">   &lt;not supported&gt;      stalled-cycles-backend</span><br><span class="line">    10,504,412,147      instructions              #    1.06  insns per cycle          (100.00%)</span><br><span class="line">     1,925,721,763      branches                  #  485.987 M/sec                    (100.00%)</span><br><span class="line">            55,018      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       3.955251872 seconds time elapsed</span><br></pre></td></tr></table></figure>

<p>在鲲鹏920下的运行时间和IPC，两个循环最终执行时间一样，但是加锁的循环 IPC 反而要高，应该是加锁指令简单，比乘法对流水线更友好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#java test.LockBenchmark  //鲲鹏920</span><br><span class="line">Time spent is 37037ms without lock:10810.40962948895</span><br><span class="line">start runIncrementWithLock.</span><br><span class="line">Time spent is 37045ms with lock:10817.060142949109  //极低的概率这里能跑出来15秒，应该是偷鸡优化了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#perf stat -p `jps | grep LockBenchmark | awk &#x27;&#123; print $1 &#125;&#x27;`</span><br><span class="line">^Cfailed to read counter branches</span><br><span class="line"></span><br><span class="line"> Performance counter stats for process id &#x27;104166&#x27;:</span><br><span class="line"></span><br><span class="line">       3459.850580      task-clock (msec)         #    1.002 CPUs utilized</span><br><span class="line">               122      context-switches          #    0.035 K/sec</span><br><span class="line">                 1      cpu-migrations            #    0.000 K/sec</span><br><span class="line">               257      page-faults               #    0.074 K/sec</span><br><span class="line">     8,995,482,376      cycles                    #    2.600 GHz</span><br><span class="line">       344,461,881      stalled-cycles-frontend   #    3.83% frontend cycles idle</span><br><span class="line">     7,060,741,196      stalled-cycles-backend    #   78.49% backend  cycles idle</span><br><span class="line">     2,667,443,624      instructions              #    0.30  insns per cycle         //不带Lock 乘除法拉低了IPC</span><br><span class="line">                                                  #    2.65  stalled cycles per insn</span><br><span class="line">   &lt;not supported&gt;      branches</span><br><span class="line">        93,302,896      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       3.453102950 seconds time elapsed</span><br><span class="line">       </span><br><span class="line">#perf stat -p `jps | grep LockBenchmark | awk &#x27;&#123; print $1 &#125;&#x27;`</span><br><span class="line">^Cfailed to read counter branches</span><br><span class="line"></span><br><span class="line"> Performance counter stats for process id &#x27;100351&#x27;:</span><br><span class="line"></span><br><span class="line">       3205.548380      task-clock (msec)         #    1.002 CPUs utilized</span><br><span class="line">                97      context-switches          #    0.030 K/sec</span><br><span class="line">                 0      cpu-migrations            #    0.000 K/sec</span><br><span class="line">                93      page-faults               #    0.029 K/sec</span><br><span class="line">     8,334,345,888      cycles                    #    2.600 GHz</span><br><span class="line">        10,217,474      stalled-cycles-frontend   #    0.12% frontend cycles idle</span><br><span class="line">     6,389,615,752      stalled-cycles-backend    #   76.67% backend  cycles idle</span><br><span class="line">     4,374,642,352      instructions              #    0.52  insns per cycle         //带lock</span><br><span class="line">                                                  #    1.46  stalled cycles per insn</span><br><span class="line">   &lt;not supported&gt;      branches</span><br><span class="line">         2,053,478      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">       3.199261610 seconds time elapsed</span><br></pre></td></tr></table></figure>

<p>这个代码加锁后指令多了1倍，所以intel CPU下体现出来的时间就差了一倍（IPC一样的）；鲲鹏 CPU下时间差不多是因为没加锁的IPC太低了（乘除法对流水线没优化好），最终IPC差了一倍，就把执行时间拉平了。另外就就是Intel和鲲鹏的执行时间对比和IPC也是一致的，IPC高执行就快。</p>
<h3 id="Disruptor中对cache-line的使用"><a href="#Disruptor中对cache-line的使用" class="headerlink" title="Disruptor中对cache_line的使用"></a>Disruptor中对cache_line的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">abstract class RingBufferPad</span><br><span class="line">&#123;</span><br><span class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">abstract class RingBufferFields&lt;E&gt; extends RingBufferPad</span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    private final long indexMask;</span><br><span class="line">    private final Object[] entries;</span><br><span class="line">    protected final int bufferSize;</span><br><span class="line">    protected final Sequencer sequencer;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final class RingBuffer&lt;E&gt; extends RingBufferFields&lt;E&gt; implements Cursored, EventSequencer&lt;E&gt;, EventSink&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点留意上述代码中的p1-p7这几个没有用的long变量，实际使用来占位，占住实际变量前后的位置，这样避免这些变量被其他变量的修改而失效。</p>
<p><img src="/images/951413iMgBlog/1620984677390-81694fd0-0323-4052-98d1-32be39a02248-4505908.png" alt="image.png"></p>
<p>队列大部分时候都是空的（head挨着tail），也就导致head 和 tail在一个cache line中，读和写会造成没必要的cache ping-pong，一般可以通过将head 和 tail 中间填充其它内容来实现错开到不同的cache line中</p>
<p><img src="/images/oss/1577093636588-6b58c36c-1617-4f2c-aba9-156c52972689.png" alt="image"></p>
<p>数组(RingBuffer)基本能保证元素在内存中是连续的，但是Queue（链表）就不一定了，连续的话更利于CPU cache</p>
<h2 id="Intel-PAUSE指令变化是如何影响自旋锁以及MySQL的性能的"><a href="#Intel-PAUSE指令变化是如何影响自旋锁以及MySQL的性能的" class="headerlink" title="Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的"></a>Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的</h2><p>MySQL利用Intel 的Pause指令在spinlock(自旋锁)的时候尽量避免cache line ping-pong，但是不同的Intel芯片每个Pause指令背后实际执行的circle是不一样的，从而导致MySQL性能差异很大</p>
<p>详细请看：</p>
<p>[《Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的》 从一个参数引起的rt抖动定位到OS锁等待再到CPU Pause指令，以及不同CPU型号对Pause使用cycles不同的影响，最终反馈到应用层面的rt全过程。在MySQL内核开发的时候考虑了Pause，但是没有考虑不同的CPU型号，所以换了CPU型号后性能差异比较大](&#x2F;2019&#x2F;12&#x2F;16&#x2F;Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的&#x2F;)</p>
<h3 id="pause-和-spinlock"><a href="#pause-和-spinlock" class="headerlink" title="pause 和 spinlock"></a>pause 和 spinlock</h3><p><a target="_blank" rel="noopener" href="http://linuxperf.com/?p=138">spinlock(自旋锁)</a>是内核中最常见的锁，它的特点是：等待锁的过程中不休眠，而是占着CPU空转，优点是避免了上下文切换的开销，缺点是该CPU空转属于浪费, 同时还有可能导致cache ping-pong，<strong>spinlock适合用来保护快进快出的临界区</strong>。持有spinlock的CPU不能被抢占，持有spinlock的代码不能休眠</p>
<h2 id="ECS-cache-line-miss导致整个物理机响应慢"><a href="#ECS-cache-line-miss导致整个物理机响应慢" class="headerlink" title="ECS cache_line miss导致整个物理机响应慢"></a>ECS cache_line miss导致整个物理机响应慢</h2><p><a target="_blank" rel="noopener" href="https://topic.atatech.org/articles/100065">如果一台ECS运行大量的cache_line miss逻辑</a>，也就是利用spinlock所保护的区域没有按照cacheline对齐的时候，CPU为了保证数据一致性，会触发Super Queue lock splits，将总线锁住，哪怕是其他socket，而这个时候，其他CPU CORE访问L2cache、L3cahe、以及内存就会阻塞，直到Super Queue lock splits释放。</p>
<p>这个影响不是socket、node内部，而是整个物理机总线被锁，所以影响的是整个物理机。</p>
<h3 id="从地址不对齐访问到split-lock"><a href="#从地址不对齐访问到split-lock" class="headerlink" title="从地址不对齐访问到split lock"></a><a target="_blank" rel="noopener" href="https://kernel.taobao.org/2019/07/Detecting-and-handling-split-locks/">从地址不对齐访问到split lock</a></h3><p>Intel CPU微架构允许不对齐的内存访问，但ARM、RISC-V等架构却不允许。在众多的不对齐中，一个特殊的场景是：<a target="_blank" rel="noopener" href="https://lwn.net/Articles/790464/">原子操作的操作数（由于地址不对齐）跨越两个cache lines，Intel将之叫做split lock。</a>它有两个特征：</p>
<ol>
<li>原子操作，即汇编指令包含Lock前缀；</li>
<li>操作数地址不对齐，还跨越两个cache lines；</li>
</ol>
<p>其实大部分吃瓜群众都不知道这个特性，但是它却对应用性能影响极大。Intel工程师Fenghua Yu同学正在开发一组内核补丁，用于检测和处理split lock，现在已经发出了第8版<a target="_blank" rel="noopener" href="https://lwn.net/ml/linux-kernel/1556134382-58814-1-git-send-email-fenghua.yu%40intel.com/">code review</a>。阿里巴巴在多年前就意识到split lock的危害，在线上实施了大规模监控，并采取必要隔离措施。</p>
<p>学过体系结构的同学都应该知道，缓存一制性协议MESI只能保证cache line粒度的一致性。同时访问两个cache lines不是常见操作，为保证split lock的原子性，设计硬件时使用特殊逻辑（冷路径）来处理：<strong>锁住整个访存总线，阻止其它逻辑cpu访存</strong>。</p>
<p>从原理出发，我们很容易想到，锁住总线将导致其它core上访存操作受阻，宏观表现为平均访存延时显著上升。为不让各位看官白走一趟，小编在自己的skylake机器上测了一组数据，随着split lock速率的增加，访存延迟呈指数恶化。</p>
<p><img src="/images/951413iMgBlog/1.png" alt="img"></p>
<h2 id="分支预测案例"><a href="#分支预测案例" class="headerlink" title="分支预测案例"></a>分支预测案例</h2><p>这个案例总循环次数一样多，但是里外循环次数不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">long timediff(clock_t t1, clock_t t2) &#123;</span><br><span class="line">    long elapsed;</span><br><span class="line">    elapsed = ((double)t2 - t1) / CLOCKS_PER_SEC * 1000;</span><br><span class="line">    return elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int j=0;</span><br><span class="line">    int k=0;</span><br><span class="line">    int c=0;</span><br><span class="line">    clock_t start=clock();</span><br><span class="line">    for(j=0; j&lt;100000; j++)&#123;</span><br><span class="line">        for(k=0; k&lt;1000; k++)&#123;</span><br><span class="line">					for(c=0; c&lt;100; c++)&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end =clock();</span><br><span class="line">    printf(&quot;%lu\n&quot;, timediff(start,end));    //case1</span><br><span class="line"></span><br><span class="line">    start=clock();</span><br><span class="line">    for(j=0; j&lt;100; j++)&#123;</span><br><span class="line">        for(k=0; k&lt;1000; k++)&#123;</span><br><span class="line">					for(c=0; c&lt;100000; c++)&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end =clock();</span><br><span class="line">    printf(&quot;%lu\n&quot;, timediff(start,end));   //case2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86_64下的执行结果，确实是case2略快</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#taskset -c 0 ./for_prediction.out</span><br><span class="line">25560</span><br><span class="line">23420</span><br><span class="line"></span><br><span class="line">#taskset -c 0 ./for_prediction.out</span><br><span class="line">25510</span><br><span class="line">23410</span><br></pre></td></tr></table></figure>

<p>case1的branch miss大概接近1%（看0 core上的 BrchMiss%， 数据由 xperf 1.3.8采集）</p>
<p><img src="/images/951413iMgBlog/image-20210517111209985.png" alt="image-20210517111209985"></p>
<p>case2的branch miss降到了0，不过两者在x86上的IPC都是0.49，所以最终的执行时间差异不大</p>
<p><img src="/images/951413iMgBlog/image-20210517111244550.png" alt="image-20210517111244550"></p>
<p><img src="/images/951413iMgBlog/image-20210512133536939.png" alt="image-20210512133536939"></p>
<p>在arm下case1反而更快，如截图</p>
<p><img src="/images/951413iMgBlog/image-20210512132121856.png" alt="image-20210512132121856"></p>
<h2 id="系列文章-1"><a href="#系列文章-1" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/">CPU的制造和概念</a></p>
<p>[CPU 性能和Cache Line](&#x2F;2021&#x2F;05&#x2F;16&#x2F;CPU Cache Line 和性能&#x2F;)</p>
<p>[Perf IPC以及CPU性能](&#x2F;2021&#x2F;05&#x2F;16&#x2F;Perf IPC以及CPU利用率&#x2F;)</p>
<p><a href="/2021/06/18/%E5%87%A0%E6%AC%BECPU%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/">Intel、海光、鲲鹏920、飞腾2500 CPU性能对比</a></p>
<p><a href="/2021/05/15/%E9%A3%9E%E8%85%BEARM%E8%8A%AF%E7%89%87(FT2500)%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">飞腾ARM芯片(FT2500)的性能测试</a></p>
<p><a href="/2021/05/14/%E5%8D%81%E5%B9%B4%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E4%B8%8D%E6%95%A2%E6%8B%A5%E6%8A%B1NUMA/">十年后数据库还是不敢拥抱NUMA？</a></p>
<p><a href="/2021/03/07/%E4%B8%80%E6%AC%A1%E6%B5%B7%E5%85%89%E7%89%A9%E7%90%86%E6%9C%BA%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E5%8E%8B%E6%B5%8B%E7%9A%84%E8%AE%B0%E5%BD%95/">一次海光物理机资源竞争压测的记录</a></p>
<p>[Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的](&#x2F;2019&#x2F;12&#x2F;16&#x2F;Intel PAUSE指令变化是如何影响自旋锁以及MySQL的性能的&#x2F;)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://scholarworks.sjsu.edu/cgi/viewcontent.cgi?referer=https://www.google.com/&httpsredir=1&article=1001&context=etd_projects">Analysis of False Cache Line Sharing Effects on Multicore CPUs</a></p>
<p><a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/articles/avoiding-and-identifying-false-sharing-among-threads.html">Avoiding and Identifying False Sharing Among Threads</a></p>
<p><a target="_blank" rel="noopener" href="http://igoro.com/archive/gallery-of-processor-cache-effects/">Gallery of Processor Cache Effects</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/10249.html">7个示例科普CPU CACHE</a></p>
<p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/11413855/why-is-transposing-a-matrix-of-512x512-much-slower-than-transposing-a-matrix-of?spm=ata.21736010.0.0.43c1e11aGARvVj">Why is transposing a matrix of 512×512 much slower than transposing a matrix of 513×513 ?</a> 矩阵倒置的时候因为同一个cache_line的数据频繁被update导致cache_line失效，也就是FALSE share</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58881925">CPU时间都去哪了：一步步定位数据库代码中的性能瓶颈(SAP)</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/20793.html">与程序员相关的CPU缓存知识</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/performance/" rel="tag"># performance</a>
              <a href="/tags/CPU/" rel="tag"># CPU</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/cache-line/" rel="tag"># cache_line</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/16/Perf%20IPC%E4%BB%A5%E5%8F%8ACPU%E5%88%A9%E7%94%A8%E7%8E%87/" rel="prev" title="Perf IPC以及CPU性能">
                  <i class="fa fa-angle-left"></i> Perf IPC以及CPU性能
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/" rel="next" title="CPU的制造和概念">
                  CPU的制造和概念 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">twitter @plantegg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
